<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Medical Certificate (MC) Use — Live Scan</title>

<style>
  :root { --gap: 12px; }
  * { box-sizing: border-box; }
  html, body { margin:0; padding:0; }
  body {
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    line-height:1.35; color:#111; background:#fff; overflow-x:hidden;
  }
  .wrap { max-width: 680px; width:100%; margin:16px auto 56px; padding:0 12px; }
  h2 { margin:8px 0 6px; font-size:1.25rem; }
  .muted { color:#666; font-size:.92rem; margin-bottom:10px; }

  fieldset { border:1px solid #e5e5e5; border-radius:12px; padding:12px; }
  label { display:block; margin:10px 0 6px; font-weight:600; }
  select, input[type=file], input[type=text], button {
    display:block; width:100%; font-size:16px; padding:10px; border-radius:12px;
    border:1px solid #d7d7d7; background:#fff;
  }
  input[type=file] { padding:8px; }
  button { background:#0a7a2f; color:#fff; border:none; font-weight:600; }
  button.secondary { background:#e9ecef; color:#111; border:1px solid #d7d7d7; }
  button:disabled { opacity:.6; }

  .grid { display:grid; grid-template-columns:1fr; gap:var(--gap); }
  @media (min-width:900px){ .grid.two{ grid-template-columns:1fr 1fr; } }

  .preview {
    width:100%; height:auto; max-height:240px; object-fit:contain;
    border:1px dashed #cfcfcf; border-radius:12px; background:#fafafa;
  }
  .log {
    font-family: ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;
    font-size:.95rem; white-space:pre-wrap; background:#fafafa; border:1px solid #eee;
    border-radius:12px; padding:10px;
  }
  .ok{color:#0a7a2f}.err{color:#b00020}

  /* Scanner modal */
  .modal { position:fixed; inset:0; background:rgba(0,0,0,.55); display:none; z-index:9999; }
  .modal.open { display:flex; align-items:center; justify-content:center; }
  .scan-card {
    width:min(720px, 95vw); height:min(85vh, 680px);
    background:#fff; border-radius:14px; padding:12px; display:flex; flex-direction:column; gap:10px;
  }
  .scan-head { display:flex; justify-content:space-between; align-items:center; gap:8px; }
  .scan-head b { font-size:1rem; }
  .scan-body { position:relative; flex:1; border:1px solid #e5e5e5; border-radius:12px; overflow:hidden; background:#000; }
  #camVideo { width:100%; height:100%; object-fit:cover; transform: translateZ(0); will-change: transform; } /* iOS paint keep-alive */
  #camCanvas, #boxCanvas { position:absolute; inset:0; }
  .scan-foot { display:flex; gap:8px; flex-wrap:wrap; }
  .chip { font-size:.9rem; padding:6px 10px; border-radius:999px; background:#f1f3f5; border:1px solid #e9ecef; }
</style>

<!-- Tesseract OCR -->
<script src="https://cdn.jsdelivr.net/npm/tesseract.js@4/dist/tesseract.min.js"></script>
<!-- Quagga2 (fallback if BarcodeDetector unsupported) -->
<script src="https://cdn.jsdelivr.net/npm/quagga2@1.8.4/dist/quagga.min.js"></script>
<!-- HEIC -> JPEG (for MC upload only) -->
<script src="https://cdn.jsdelivr.net/npm/heic2any@0.0.4/dist/heic2any.min.js"></script>
</head>
<body>
  <div class="wrap">
    <h2>Medical Certificate (MC) Use</h2>
    <p class="muted">Live-scan the sticker (no photo saved). Only the MC photo is uploaded to Drive.</p>

    <form id="mcForm">
      <fieldset>
        <label for="zone">Zone</label>
        <select id="zone" required>
          <option value="">— Select —</option>
          <option>Green</option><option>Yellow</option><option>Red</option>
        </select>

        <div class="grid two">
          <div>
            <label>Sticker (live scan)</label>
            <div class="grid">
              <button type="button" id="openScan" class="secondary">Scan sticker now</button>
              <div class="log" id="detectedBox">— waiting —</div>
            </div>
          </div>

          <div>
            <label for="mcfile">Medical Certificate photo (saved)</label>
            <input type="file" id="mcfile" accept="image/*" capture="environment" required />
            <img id="mcPreview" class="preview" alt="">
          </div>
        </div>

        <div class="grid two" style="margin-top:var(--gap)">
          <div>
            <label>Manual override (optional)</label>
            <input type="text" id="nameManual" placeholder="Name (override)">
            <input type="text" id="mrnManual" placeholder="MRN (UPMxxxxxxxxx)">
          </div>
          <div>
            <label>Status</label>
            <div id="status" class="log">Idle</div>
          </div>
        </div>

        <div style="margin-top:var(--gap)"><button id="submitBtn" type="submit">Submit</button></div>
      </fieldset>
    </form>
  </div>

  <!-- Live scanner modal -->
  <div id="scanModal" class="modal" aria-hidden="true">
    <div class="scan-card">
      <div class="scan-head">
        <b>Scan sticker (live)</b>
        <span id="scanHint" class="chip">Align barcode; hold steady</span>
      </div>
      <div class="scan-body">
        <video id="camVideo" playsinline autoplay muted></video>
        <canvas id="camCanvas"></canvas>
        <canvas id="boxCanvas"></canvas>
      </div>
      <div class="scan-foot">
        <button type="button" id="closeScan" class="secondary">Cancel</button>
        <button type="button" id="toggleTorch" class="secondary">Toggle torch</button>
      </div>
    </div>
  </div>

<script>
/* ===== CONFIG ===== */
const GAS_URL = "https://script.google.com/macros/s/AKfycbwoijzTp_nlEfdXawiLNxPXu0e5sH9qM5FOSJFkzJVoUA0kGZjRAbZAcM1wUJmRwMuC/exec";
const MAX_DIM_UPLOAD = 1400; // resize MC before upload (speed)
const OCR_TIMEOUT_MS = 6000;
const BARCODE_INTERVAL_MS = 160;  // detect every ~160ms

/* ===== DOM ===== */
const $ = id => document.getElementById(id);
const zoneEl = $("zone");
const detectedBox = $("detectedBox");
const statusEl = $("status");
const submitBtn = $("submitBtn");
const mcInput = $("mcfile");
const mcPreview = $("mcPreview");

const scanModal = $("scanModal");
const camVideo = $("camVideo");
const camCanvas = $("camCanvas");
const boxCanvas = $("boxCanvas");
const openScanBtn = $("openScan");
const closeScanBtn = $("closeScan");
const toggleTorchBtn = $("toggleTorch");
const scanHint = $("scanHint");

const nameManual = $("nameManual");
const mrnManual = $("mrnManual");

/* ===== State ===== */
let stream = null;
let track = null;
let detector = null;
let scanning = false;
let detectTimer = null;
let tesseractWorker = null;
let torchOn = false;

let foundName = "";
let foundMRN  = "";

/* ===== Utils ===== */
function setStatus(msg, ok=false, err=false){
  statusEl.textContent = msg;
  statusEl.className = "log" + (ok ? " ok" : "") + (err ? " err" : "");
}
const normalizeMrn = (raw) => {
  if (!raw) return null;
  const upm = (raw.match(/\b(UPM\d{6,12})\b/i)||[])[1];
  if (upm) return upm.toUpperCase();
  const digits = (raw.match(/\b(\d{6,12})\b/)||[])[1];
  return digits ? ("UPM"+digits) : null;
};
function fitWithin(w,h,max){ const s=Math.min(1, max/Math.max(w,h)); return { w:Math.round(w*s), h:Math.round(h*s) }; }
function blobFromCanvas(canvas, type="image/jpeg", q=0.9){ return new Promise(r => canvas.toBlob(r, type, q)); }
function drawBox(bbox, color="lime"){
  const ctx = boxCanvas.getContext("2d");
  ctx.clearRect(0,0,boxCanvas.width,boxCanvas.height);
  if (!bbox) return;
  ctx.strokeStyle = color; ctx.lineWidth = 3;
  ctx.strokeRect(bbox.x, bbox.y, bbox.width, bbox.height);
}

/* ===== Tesseract worker (lazy) ===== */
async function getWorker(){
  if (tesseractWorker) return tesseractWorker;
  const { createWorker } = Tesseract;
  tesseractWorker = await createWorker({ logger:()=>{} });
  await tesseractWorker.loadLanguage("eng");
  await tesseractWorker.initialize("eng");
  await tesseractWorker.setParameters({
    tessedit_char_whitelist: "ABCDEFGHIJKLMNOPQRSTUVWXYZ @'-.",
    preserve_interword_spaces: "1",
    tessedit_pageseg_mode: "7" // single line
  });
  return tesseractWorker;
}

/* ===== Live scanner (iOS-friendly) ===== */
async function startScan(){
  scanModal.classList.add("open");
  detectedBox.textContent = "— scanning —";
  foundName = ""; foundMRN = ""; drawBox(null);

  try {
    // Prepare detector if available
    detector = null;
    if ("BarcodeDetector" in window) {
      try {
        const supported = await BarcodeDetector.getSupportedFormats();
        const fmts = ['code_128','code_39','code_93','itf','codabar','ean_13','ean_8','pdf417'].filter(f=>supported.includes(f));
        detector = new BarcodeDetector({ formats: fmts.length ? fmts : ['code_128','code_39','itf'] });
      } catch { detector = null; }
    }

    // Start camera
    stream = await navigator.mediaDevices.getUserMedia({
      video: { facingMode: { ideal: "environment" }, width: { ideal: 1280 }, height: { ideal: 720 } },
      audio: false
    });
    camVideo.srcObject = stream;
    camVideo.setAttribute("playsinline",""); // iOS
    camVideo.muted = true;
    track = stream.getVideoTracks()[0];

    // Wait for metadata for correct videoWidth/Height
    await new Promise(res => {
      const onMeta = () => { camVideo.removeEventListener("loadedmetadata", onMeta); res(); };
      if (camVideo.readyState >= 1) res(); else camVideo.addEventListener("loadedmetadata", onMeta);
    });
    await camVideo.play();

    // Size canvases to actual video dimensions
    const vw = camVideo.videoWidth || 1280;
    const vh = camVideo.videoHeight || 720;
    camCanvas.width = boxCanvas.width = vw;
    camCanvas.height = boxCanvas.height = vh;

    scanning = true;

    // Use interval loop (more reliable than rAF in modals on iOS)
    if (detectTimer) clearInterval(detectTimer);
    detectTimer = setInterval(detectFrame, BARCODE_INTERVAL_MS);
    setStatus("Camera on. Align barcode; hold steady.", true);
  } catch (e) {
    console.error(e);
    detectedBox.textContent = "Camera permission blocked or unavailable.";
    setStatus("Camera unavailable", false, true);
  }
}

function stopScan(){
  scanning = false;
  if (detectTimer) { clearInterval(detectTimer); detectTimer = null; }
  drawBox(null);
  try { if (stream) stream.getTracks().forEach(t => t.stop()); } catch {}
  stream = null; track = null;
  scanModal.classList.remove("open");
}

async function detectFrame(){
  if (!scanning || !camVideo || camVideo.readyState < 2) return;

  // Re-sync canvas size if Safari updates video size after play()
  const vw = camVideo.videoWidth, vh = camVideo.videoHeight;
  if (vw && vh && (vw !== camCanvas.width || vh !== camCanvas.height)) {
    camCanvas.width = boxCanvas.width = vw;
    camCanvas.height = boxCanvas.height = vh;
  }

  const ctx = camCanvas.getContext("2d");
  ctx.drawImage(camVideo, 0, 0, camCanvas.width, camCanvas.height);

  // 1) Try native BarcodeDetector
  if (detector){
    try{
      const codes = await detector.detect(camCanvas);
      if (codes && codes.length){
        let best = codes[0];
        for (const c of codes) if ((c.rawValue||'').length > (best.rawValue||'').length) best = c;
        const bbox = best.boundingBox || rectFromPoints(best.cornerPoints);
        const mrn = normalizeMrn(String(best.rawValue||'').trim());
        if (bbox) drawBox(bbox, mrn ? "lime" : "orange");
        if (mrn) { scanning = false; if (detectTimer){clearInterval(detectTimer); detectTimer=null;} await handleFound(camCanvas, bbox, mrn); return; }
      } else {
        drawBox(null);
      }
    } catch (_) {}
    return;
  }

  // 2) Fallback to Quagga snapshot
  await new Promise(resolve=>{
    const dataUrl = camCanvas.toDataURL("image/jpeg", 0.85);
    Quagga.decodeSingle({
      src: dataUrl, numOfWorkers: 0, locate: true,
      inputStream: { size: 800 },
      locator: { halfSample: true, patchSize: "medium" },
      decoder: { readers: ["code_128_reader","code_39_reader","i2of5_reader","codabar_reader"] }
    }, res=>{
      if (res && res.codeResult && res.codeResult.code){
        const mrn = normalizeMrn(String(res.codeResult.code));
        const bbox = res.box ? rectFromPoints(res.box.map(([x,y])=>({x,y}))) : null;
        if (bbox) drawBox(bbox, mrn ? "lime" : "orange");
        if (mrn) { scanning = false; if (detectTimer){clearInterval(detectTimer); detectTimer=null;} handleFound(camCanvas, bbox, mrn).then(resolve); return; }
      } else {
        drawBox(null);
      }
      resolve();
    });
  });
}

function rectFromPoints(pts){
  if (!pts || !pts.length) return null;
  const xs = pts.map(p=>p.x), ys = pts.map(p=>p.y);
  const x = Math.min(...xs), y = Math.min(...ys);
  const w = Math.max(...xs)-x, h = Math.max(...ys)-y;
  return { x, y, width:w, height:h };
}

async function handleFound(frameCanvas, bbox, mrn){
  try{
    foundMRN = mrn;
    scanHint.textContent = "Barcode found. Reading name…";
    // Crop a region above the barcode to OCR the name
    const m = Math.round(Math.max(6, bbox.height * 0.25));
    const x = Math.max(0, Math.floor(bbox.x - m));
    const w = Math.min(frameCanvas.width - x, Math.floor(bbox.width + 2*m));
    const yBottom = Math.max(0, Math.floor(bbox.y - m));
    const h = Math.min(frameCanvas.height, Math.floor(2*bbox.height + m));
    const y = Math.max(0, yBottom - h);

    const crop = document.createElement("canvas");
    crop.width = w; crop.height = h;
    const cctx = crop.getContext("2d");
    cctx.drawImage(frameCanvas, x, y, w, h, 0, 0, w, h);

    // OCR once (single line)
    const worker = await getWorker();
    const res = await Promise.race([
      worker.recognize(crop),
      new Promise(r => setTimeout(()=>r(null), OCR_TIMEOUT_MS))
    ]);
    let name = "";
    if (res && res.data && res.data.text){
      name = String(res.data.text).toUpperCase().replace(/\s{2,}/g,' ').trim();
      name = name.replace(/^[^A-Z0-9]+|[^A-Z0-9 @'\.-]+$/g,'').trim();
    }

    foundName = name;
    detectedBox.textContent = `Name=${foundName || "—"}  |  MRN=${foundMRN || "—"}`;
    scanHint.textContent = "Done. You can close this window.";
  } catch(e){
    detectedBox.textContent = `Detected MRN=${mrn}. Name OCR failed; you can type it.`;
  }
}

/* Torch toggle (if supported) */
toggleTorchBtn.addEventListener("click", async ()=>{
  if (!track) return;
  try{
    torchOn = !torchOn;
    await track.applyConstraints({ advanced: [{ torch: torchOn }]});
  }catch(_){
    alert("Torch not supported on this device.");
  }
});

/* Open/Close scan */
openScanBtn.addEventListener("click", startScan);
closeScanBtn.addEventListener("click", ()=>{
  stopScan();
  // Fill overrides from last found values for convenience
  if (foundName) nameManual.value = foundName;
  if (foundMRN)  mrnManual.value  = foundMRN;
});

/* ===== MC upload (only MC is sent to server) ===== */
mcInput.addEventListener("change", async ()=>{
  if (!mcInput.files[0]) return;
  setStatus("Processing MC…");
  const blob = await normalizeForUpload(mcInput.files[0]);
  showPreviewBlob(blob, mcPreview);
  mcUploadBlob = blob;
  setStatus("MC ready", true);
});

let mcUploadBlob = null;
function showPreviewBlob(blob, imgEl){ const url=URL.createObjectURL(blob); imgEl.src=url; imgEl.onload=()=>URL.revokeObjectURL(url); }

async function normalizeForUpload(file){
  // HEIC -> JPEG
  if (/image\/hei(c|f)/i.test(file.type) || /\.hei(c|f)$/i.test(file.name)) {
    const r = await heic2any({ blob:file, toType:"image/jpeg", quality:0.92 });
    file = new File([Array.isArray(r)?r[0]:r], (file.name.replace(/\.[^\.]+$/,'')||'image')+".jpg", { type:"image/jpeg" });
  }
  // Resize
  const img = await new Promise((res,rej)=>{ const u=URL.createObjectURL(file); const i=new Image(); i.onload=()=>{URL.revokeObjectURL(u);res(i)}; i.onerror=rej; i.src=u; });
  const {w,h} = fitWithin(img.naturalWidth||img.width, img.naturalHeight||img.height, MAX_DIM_UPLOAD);
  const can = document.createElement("canvas"); can.width=w; can.height=h;
  const ctx = can.getContext("2d"); ctx.drawImage(img,0,0,w,h);
  return await new Promise(r => can.toBlob(r, "image/jpeg", 0.85));
}

function blobToBase64(blob){ return new Promise((res,rej)=>{ const fr=new FileReader(); fr.onload=()=>res(String(fr.result).split(",")[1]||""); fr.onerror=rej; fr.readAsDataURL(blob); }); }

/* ===== Submit ===== */
document.getElementById("mcForm").addEventListener("submit", async (e)=>{
  e.preventDefault();
  if (!zoneEl.value || !mcInput.files[0]){
    alert("Please pick a Zone and choose the MC photo."); return;
  }
  // Prefer scanned values but allow manual overrides
  const name = nameManual.value.trim() || foundName || "";
  const mrn  = (mrnManual.value.trim().toUpperCase()) || foundMRN || "";

  if (!mcUploadBlob) mcUploadBlob = await normalizeForUpload(mcInput.files[0]);

  setStatus("Uploading MC & writing row…");
  submitBtn.disabled = true;
  try{
    const mcB64 = await blobToBase64(mcUploadBlob);
    const payload = {
      zone: zoneEl.value,
      nameOverride: name || null,
      mrnOverride: mrn || null,
      mcfile: { name: mcInput.files[0].name, mime: "image/jpeg", b64: mcB64 }
    };
    const resp = await fetch(GAS_URL, {
      method:"POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload)
    });
    if (!resp.ok){ const txt = await resp.text(); throw new Error(`HTTP ${resp.status} – ${txt.slice(0,200)}`); }
    const data = await resp.json();
    if (!data.ok) throw new Error(data.error || "Unknown server error");

    setStatus("Success ✔ Files uploaded & row added.", true);
    detectedBox.textContent = `Name=${data.name || name || "—"}  |  MRN=${data.mrn || mrn || "—"}`;
  }catch(err){
    console.error(err);
    setStatus("Failed: " + err.message, false, true);
    alert("Error:\n" + err.message);
  }finally{
    submitBtn.disabled = false;
  }
});
</script>
</body>
</html>
