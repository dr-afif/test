<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />
  <title>Mobile Barcode Scanner • Minimal</title>
  <style>
    :root {
      --bg: #0b1020;
      --card: #121a2f;
      --text: #e8eefc;
      --muted: #a7b0c8;
      --accent: #4f86ff;
      --good: #15c27a;
      --warn: #ffb020;
      --bad:  #ff5a5a;
      --shadow: 0 10px 30px rgba(0,0,0,0.35);
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji";
      background: var(--bg);
      color: var(--text);
      -webkit-tap-highlight-color: transparent;
      overflow-x: hidden;
    }
    .app {
      min-height: 100dvh;
      display: grid;
      grid-template-rows: auto 1fr auto;
      gap: 12px;
      padding: max(12px, env(safe-area-inset-top)) max(12px, env(safe-area-inset-right)) max(16px, env(safe-area-inset-bottom)) max(12px, env(safe-area-inset-left));
    }
    header {
      display: flex; align-items: center; justify-content: space-between;
      gap: 8px; padding: 8px 4px;
    }
    .title { font-weight: 700; letter-spacing: 0.2px; }
    .muted { color: var(--muted); font-size: 0.9rem; }
    /* Viewfinder container + guide */
    .video-wrap {
      position: relative;
      background: #060a15;
      border-radius: 16px;
      box-shadow: var(--shadow);
      overflow: hidden;
      aspect-ratio: 12/7; /* keep in sync with guide */
      max-height: 42vh;
    }
    .guide-box { position: absolute; inset: 0; display: grid; place-items: center; pointer-events: none; }
    .guide-box::before { content: ""; display: block; width: 90%; aspect-ratio: 12/7; border: 2px solid rgba(255,255,255,0.45); border-radius: 10px; box-shadow: inset 0 0 0 1px rgba(0,0,0,0.12); }
    @media (min-width: 680px) { .video-wrap { max-height: 50vh; } .guide-box::before { width: 86%; } }
    video { width: 100%; height: 100%; object-fit: cover; display: block; }
    .guides { display: none !important; }
    .guide-rect { display: none !important; }
    .corner { display: none !important; }
    .hint { position: absolute; left: 50%; top: 8px; transform: translateX(-50%); font-size: 12px; color: var(--muted); background: rgba(0,0,0,0.35); padding: 6px 10px; border-radius: 999px; }
    .led {
      position: absolute; top: 10px; right: 10px; z-index: 3;
      padding: 4px 10px; border-radius: 999px; font-size: 12px; font-weight: 600;
      background: #1a243d; color: var(--muted); border: 1px solid #2a375f;
    }
    .led.on { background: #112b1f; color: #b2f5dc; border-color: #1f6a4f; }

    .controls {
      display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px;
      margin-top: 10px;
    }
    button, select, input[type="file"] {
      appearance: none; -webkit-appearance: none;
      background: var(--card); color: var(--text);
      border: 1px solid #243055; border-radius: 12px; padding: 12px; font-weight: 600;
      box-shadow: var(--shadow);
      width: 100%;
    }
    button.primary { background: var(--accent); border-color: transparent; color: white; }
    button.good { background: var(--good); border-color: transparent; color: #04281a; }
    button.warn { background: var(--warn); border-color: transparent; color: #2a1f07; }
    button:disabled { opacity: 0.5; }
    label.file { display: inline-flex; align-items: center; justify-content: center; gap: 8px; cursor: pointer; }
    label.file input { display: none; }

    .result {
      margin-top: 8px; padding: 12px; border-radius: 14px; background: var(--card); border: 1px solid #263560;
    }
    .result h3 { margin: 0 0 8px; font-size: 1rem; }
    .kv { display: grid; grid-template-columns: 120px 1fr; gap: 6px 10px; font-size: 0.95rem; }
    .kv div:nth-child(odd) { color: var(--muted); }
    .code-box {
      background: #0d1427; border: 1px solid #22325c; border-radius: 10px; padding: 10px; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; word-break: break-word;
    }

    footer { color: var(--muted); font-size: 12px; text-align: center; margin-top: 8px; }
    .sr-only { position: absolute; width:1px; height:1px; padding:0; margin:-1px; overflow:hidden; clip:rect(0,0,0,0); white-space:nowrap; border:0; }

    @media (min-width: 680px) { /* desktop-friendly */
      .app { max-width: 900px; margin: 0 auto; }
      .controls { grid-template-columns: repeat(4, 1fr); }
      .video-wrap { aspect-ratio: 12/7; max-height: 50vh; }
    }
  </style>
  <!-- ZXing (UMD) for barcode scanning -->
  <script defer src="https://cdn.jsdelivr.net/npm/@zxing/library@0.20.0/umd/index.min.js"></script>
  <!-- Tesseract.js for on-device OCR (English by default) -->
  <script defer src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>
</head>
<body>
  <div class="app">
    <header>
      <div>
        <div class="title">Barcode Scanner</div>
        <div class="muted">Simple, mobile‑friendly, works offline (after first load)</div>
      </div>
      <span id="status-led" class="led" aria-live="polite">Idle</span>
    </header>

    <main>
      <section class="video-wrap">
        <video id="preview" playsinline autoplay muted></video>
        <div class="guide-box" aria-hidden="true"></div>
        <div class="hint">Align barcode within the box</div>
      </section>

      <div class="controls" role="group" aria-label="Scanner controls">
        <button id="start" class="primary">Start</button>
        <button id="stop" class="warn" disabled>Stop</button>
        <button id="torch" disabled>Torch</button>
        <select id="cameras" aria-label="Camera" title="Camera"></select>
        <label class="file"><input id="file" type="file" accept="image/*;capture=camera"> Scan Image</label>
        <button id="clear">Clear</button>
        <label style="display:flex;align-items:center;gap:8px;justify-content:center;background:#16203b;border:1px solid #243055;border-radius:12px;padding:12px;">
          <input id="pause-on-hit" type="checkbox" checked /> Pause on first hit
        </label>
        <button id="ocr" title="Run OCR on current frame">Scan Text (OCR)</button>
      </div>

      <article id="result" class="result" hidden>
        <h3>Last Scan</h3>
        <div class="kv">
          <div>Format</div><div id="fmt">—</div>
          <div>Text</div><div id="text" class="code-box">—</div>
          <div>Raw Bytes</div><div id="bytes" class="code-box">—</div>
          <div>Detected</div><div id="when">—</div>
        </div>
        <div id="parsed" style="margin-top:10px;" hidden>
          <h3>Extracted Fields</h3>
          <div class="kv">
            <div>Name</div><div id="fld-name">—</div>
            <div>MRN</div><div id="fld-mrn">—</div>
            <div>DOB</div><div id="fld-dob">—</div>
          </div>
        </div>
        <div id="ocr-wrap" style="margin-top:10px;" hidden>
          <h3>OCR Text</h3>
          <div class="code-box" id="ocr-text">—</div>
        </div>
      </article>
    </main>

    <footer>
      Works best on HTTPS. On iOS Safari: grant camera permission and keep the tab in foreground. If video is black, tap <strong>Stop</strong> → <strong>Start</strong> once.
    </footer>
  </div>

<script>
(function(){
  const $ = (sel) => document.querySelector(sel);
  const video = $('#preview');
  const statusLed = $('#status-led');
  const btnStart = $('#start');
  const btnStop = $('#stop');
  const btnTorch = $('#torch');
  const selCams = $('#cameras');
  const fileInput = $('#file');
  const pauseOnHit = $('#pause-on-hit');
  const resultCard = $('#result');
  const outFmt = $('#fmt');
  const outText = $('#text');
  const outBytes = $('#bytes');
  const outWhen = $('#when');
  const parsedWrap = $('#parsed');
  const fldName = $('#fld-name');
  const fldMrn = $('#fld-mrn');
  const fldDob = $('#fld-dob');

  let codeReader = null;
  let currentDeviceId = null;
  let currentStreamTrack = null;
  let torchOn = false;
  let scanning = false;

  // OCR setup
  const btnOCR = document.getElementById('ocr');
  const ocrWrap = document.getElementById('ocr-wrap');
  const ocrText = document.getElementById('ocr-text');
  const workCanvas = document.createElement('canvas');
  const workCtx = workCanvas.getContext('2d', { willReadFrequently: true });

  function setLed(text, cls) {
    statusLed.textContent = text;
    statusLed.className = 'led' + (cls ? ' ' + cls : '');
  }
  function setButtons() {
    btnStart.disabled = scanning;
    btnStop.disabled = !scanning;
    btnTorch.disabled = !currentStreamTrack || !getTorchCapability(currentStreamTrack);
  }
  function getTorchCapability(track){
    try {
      const caps = track?.getCapabilities?.();
      return !!(caps && 'torch' in caps);
    } catch { return false; }
  }
  async function toggleTorch(){
    if (!currentStreamTrack) return;
    torchOn = !torchOn;
    try {
      await currentStreamTrack.applyConstraints({ advanced: [{ torch: torchOn }] });
      btnTorch.textContent = torchOn ? 'Torch Off' : 'Torch';
    } catch(e){ console.warn('Torch unsupported', e); }
  }

  async function listCameras(){
    try {
      const devices = await navigator.mediaDevices.enumerateDevices();
      const cams = devices.filter(d => d.kind === 'videoinput');
      selCams.innerHTML = '';
      cams.forEach((d,i)=>{
        const opt = document.createElement('option');
        const label = d.label || `Camera ${i+1}`;
        opt.value = d.deviceId;
        opt.textContent = label;
        selCams.appendChild(opt);
      });
      // Prefer a camera labeled as back/environment if available
      const back = cams.find(d => /back|rear|environment/i.test(d.label));
      if (back) selCams.value = back.deviceId;
      if (!selCams.value && cams[0]) selCams.value = cams[0].deviceId;
    } catch (e){ console.error('enumerateDevices failed', e); }
  }

  async function startScan(){
    if (scanning) return;
    if (!('mediaDevices' in navigator) || !('getUserMedia' in navigator.mediaDevices)){
      alert('Camera not supported on this browser. Try a modern Safari/Chrome/Edge.');
      return;
    }
    setLed('Requesting camera…');
    setButtons();
    const ZX = window.ZXing; // UMD global
    if (!ZX) { alert('ZXing library not loaded yet. If on slow network, try again.'); return; }
    if (!codeReader) codeReader = new ZX.BrowserMultiFormatReader();

    // ensure labels are available (iOS hides until permission)
    try { await navigator.mediaDevices.getUserMedia({ video: true }); } catch(e){}
    await listCameras();

    currentDeviceId = selCams.value || null;
    scanning = true; setButtons(); setLed('Scanning…', 'on');

    try {
      await codeReader.decodeFromVideoDevice(currentDeviceId, video, (result, err) => {
        if (result) {
          handleResult(result);
          if (pauseOnHit.checked) {
            stopScan();
          }
        }
        if (err && !(err instanceof ZX.NotFoundException)) {
          console.warn(err);
        }
      });
      // Remember current track for torch
      const stream = video.srcObject;
      currentStreamTrack = stream && stream.getVideoTracks ? stream.getVideoTracks()[0] : null;
      btnTorch.disabled = !getTorchCapability(currentStreamTrack);
    } catch (e){
      console.error('decodeFromVideoDevice failed', e);
      setLed('Camera error', '');
      alert('Failed to start camera: ' + (e.message || e));
      scanning = false; setButtons();
    }
  }

  async function stopScan(){
    try { codeReader?.reset(); } catch {}
    try {
      const stream = video.srcObject; if (stream) { stream.getTracks().forEach(t => t.stop()); }
      video.srcObject = null;
    } catch {}
    currentStreamTrack = null; torchOn = false; btnTorch.textContent = 'Torch';
    scanning = false; setButtons(); setLed('Idle');
  }

  function bytesToHex(u8){
    try { return [...u8].map(b => b.toString(16).padStart(2,'0')).join(' '); } catch { return ''; }
  }

  // Capture current video frame into a canvas (downscale for speed)
  function captureFrame(scale = 1){
    if (!video || video.readyState < 2) throw new Error('Video not ready');
    const vw = video.videoWidth, vh = video.videoHeight;
    const sw = Math.max(320, Math.round(vw * scale));
    const sh = Math.max(240, Math.round(vh * scale));
    workCanvas.width = sw; workCanvas.height = sh;
    workCtx.drawImage(video, 0, 0, sw, sh);
    return workCanvas;
  }

  async function runOCR(){
    try {
      setLed('OCR…');
      const canvas = captureFrame(0.7);
      const { data } = await Tesseract.recognize(canvas, 'eng');
      const res = { data };
      const text = (res && res.data && res.data.text) ? res.data.text.trim() : '';
      ocrText.textContent = text || '—';
      ocrWrap.hidden = !text;
      if (text){
        const fields = parseCommonFields(text);
        const hasFields = fields.name || fields.mrn || fields.dob;
        if (hasFields){
          fldName.textContent = fields.name || '—';
          fldMrn.textContent = fields.mrn || '—';
          fldDob.textContent = fields.dob || '—';
          parsedWrap.hidden = false;
        }
      }
      setLed('Scanning…', 'on');
    } catch (e){
      console.error('OCR failed', e);
      alert('OCR failed: ' + (e.message || e));
      setLed(scanning ? 'Scanning…' : 'Idle');
    }
  }
  function parseCommonFields(text){
    const out = { name: '', mrn: '', dob: '' };
    // Look for MRN patterns
    const mrn = text.match(/\bMRN[:=\s]*([A-Z0-9\-]{4,})\b/i) || text.match(/\b([A-Z]{2}\d{6,})\b/);
    if (mrn) out.mrn = mrn[1];
    // Look for name patterns
    const name = text.match(/\bNAME[:=\s]*([^|;\n\r]+)\b/i) || text.match(/\bNAMA[:=\s]*([^|;\n\r]+)\b/i);
    if (name) out.name = name[1].trim();
    // Dates (DD/MM/YYYY or YYYY-MM-DD)
    const dob = text.match(/\b(\d{2}[\/.-]\d{2}[\/.-]\d{4}|\d{4}[\/.-]\d{2}[\/.-]\d{2})\b/);
    if (dob) out.dob = dob[1];
    return out;
  }

  function handleResult(result){
    try {
      const fmt = String(result.getBarcodeFormat ? result.getBarcodeFormat() : result.format || '—');
      const txt = String(result.getText ? result.getText() : result.text || '');
      const raw = result?.rawBytes || result?._rawBytes || null;
      outFmt.textContent = fmt;
      outText.textContent = txt || '—';
      outBytes.textContent = raw ? bytesToHex(new Uint8Array(raw)) : '—';
      outWhen.textContent = new Date().toLocaleString();
      resultCard.hidden = false;

      const fields = parseCommonFields(txt);
      const hasFields = fields.name || fields.mrn || fields.dob;
      if (hasFields){
        fldName.textContent = fields.name || '—';
        fldMrn.textContent = fields.mrn || '—';
        fldDob.textContent = fields.dob || '—';
        parsedWrap.hidden = false;
      } else {
        parsedWrap.hidden = true;
      }
      // brief visual flash on success
      statusLed.classList.add('on');
      setTimeout(()=>statusLed.classList.remove('on'), 250);
    } catch (e){ console.error('handleResult error', e); }
  }

  async function decodeImageFile(file){
    const ZX = window.ZXing; if (!ZX) return alert('ZXing not loaded');
    if (!codeReader) codeReader = new ZX.BrowserMultiFormatReader();
    const img = new Image();
    const url = URL.createObjectURL(file);
    img.onload = async () => {
      try {
        const res = await codeReader.decodeFromImage(img);
        if (res) handleResult(res);
      } catch (e){
        alert('No barcode found in image. Try a sharper photo.');
        console.warn(e);
      } finally {
        URL.revokeObjectURL(url);
      }
    };
    img.src = url;
  }

  
  btnOCR.addEventListener('click', runOCR);
  selCams.addEventListener('change', async () => {
    const wasScanning = scanning; await stopScan(); currentDeviceId = selCams.value; if (wasScanning) startScan();
  });
  fileInput.addEventListener('change', (e)=>{
    const f = e.target.files?.[0]; if (f) decodeImageFile(f);
  });
  $('#clear').addEventListener('click', ()=>{
    outFmt.textContent = '—'; outText.textContent = '—'; outBytes.textContent = '—'; outWhen.textContent = '—'; parsedWrap.hidden = true; resultCard.hidden = true;
  });

  // Proactive iOS hints
  document.addEventListener('visibilitychange', ()=>{
    if (document.visibilityState !== 'visible' && scanning) {
      // Pause when tab loses focus to save battery; resume manually
      stopScan();
    }
  });
})();
</script>
</body>
</html>
