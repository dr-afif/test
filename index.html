<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>MC Use – Test (Crop + HEIC + Barcode)</title>

  <style>
    body { font-family: system-ui, Arial; max-width: 860px; margin: 2rem auto; padding: 0 1rem; }
    h2 { margin-bottom: .75rem; }
    fieldset { border: 1px solid #ddd; padding: 1rem; border-radius: .5rem; }
    label { display: block; margin: .6rem 0 .3rem; }
    select, input[type=file], input[type=text], button { padding: .5rem; font-size: 1rem; }
    .row-2 { display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; }
    .muted { color: #666; font-size: .9rem; }
    .preview { margin-top: .5rem; max-width: 100%; max-height: 240px; border: 1px dashed #bbb; border-radius: .4rem; object-fit: contain; }
    .log { background:#f7f7f7; border:1px solid #eee; padding:.5rem .75rem; border-radius:.4rem; white-space:pre-wrap; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
    .ok { color: #0a7a2f; }
    .err { color: #b00020; }
    .btn-row { display:flex; gap:.5rem; flex-wrap: wrap; margin-top:.4rem; }
    .small { font-size:.9rem; padding:.35rem .6rem; }
    .hint { font-size:.85rem; color:#555; }
    .modal { position: fixed; inset: 0; background: rgba(0,0,0,0.5); display: none; align-items: center; justify-content: center; z-index: 1000; }
    .modal.open { display: flex; }
    .modal-card { background: #fff; padding: 1rem; border-radius: .6rem; max-width: 95vw; max-height: 90vh; width: 900px; display:flex; flex-direction: column; gap:.6rem; }
    .crop-wrap { flex:1; min-height: 360px; border:1px solid #ddd; position:relative; overflow:hidden; }
    .crop-wrap img { max-width: 100%; display:block; }
    .modal-actions { display:flex; flex-wrap: wrap; gap:.5rem; justify-content: space-between; align-items:center; }
    .left-actions, .right-actions { display:flex; gap:.5rem; align-items:center; }
  </style>

  <!-- OCR -->
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@4/dist/tesseract.min.js"></script>
  <!-- Cropper.js -->
  <link href="https://cdn.jsdelivr.net/npm/cropperjs@1.6.2/dist/cropper.min.css" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/cropperjs@1.6.2/dist/cropper.min.js"></script>
  <!-- HEIC -> JPEG -->
  <script src="https://cdn.jsdelivr.net/npm/heic2any@0.0.4/dist/heic2any.min.js"></script>
</head>
<body>
  <h2>Medical Certificate (MC) Use – Test</h2>
  <p class="muted">Crop images before OCR & upload. iPhone HEIC is converted to JPEG. MRN comes from barcode.</p>

  <form id="mcForm">
    <fieldset>
      <label for="zone">Zone</label>
      <select id="zone" required>
        <option value="">— Select —</option>
        <option>Green</option>
        <option>Yellow</option>
        <option>Red</option>
      </select>

      <div class="row-2">
        <div>
          <label for="sticker">Patient sticker photo</label>
          <input type="file" id="sticker" accept="image/*" capture="environment" required />
          <div class="btn-row">
            <button type="button" id="cropStickerBtn" class="small">Crop sticker</button>
          </div>
          <img id="stickerPreview" class="preview" alt="">
          <div class="hint">Crop to include only the patient name (first line) and the MRN barcode area.</div>
        </div>

        <div>
          <label for="mcfile">Medical Certificate photo</label>
          <input type="file" id="mcfile" accept="image/*" capture="environment" required />
          <div class="btn-row">
            <button type="button" id="cropMcBtn" class="small">Crop MC</button>
          </div>
          <img id="mcPreview" class="preview" alt="">
        </div>
      </div>

      <div class="row-2">
        <div>
          <label>Parsed</label>
          <div id="ocrResult" class="log muted">— waiting —</div>
        </div>
        <div>
          <label>Manual override (optional)</label>
          <input type="text" id="nameManual" placeholder="Name (override)">
          <input type="text" id="mrnManual" placeholder="MRN (UPMxxxxxxxxx)">
          <div class="hint">If filled, these override OCR/barcode results.</div>
        </div>
      </div>

      <div style="margin-top:1rem" class="btn-row">
        <button id="submitBtn" type="submit">Submit test</button>
      </div>
    </fieldset>
  </form>

  <div style="margin-top:1rem">
    <div id="status" class="log">Status: idle</div>
  </div>

  <!-- Crop Modal -->
  <div id="cropModal" class="modal" aria-hidden="true">
    <div class="modal-card">
      <strong id="cropTitle">Crop Image</strong>
      <div class="crop-wrap">
        <img id="cropImage" alt="">
      </div>
      <div class="modal-actions">
        <div class="left-actions">
          <button type="button" id="rotateLeft" class="small">⟲ Rotate -90°</button>
          <button type="button" id="rotateRight" class="small">⟳ Rotate +90°</button>
          <button type="button" id="resetCrop" class="small">Reset</button>
          <span class="hint">Zoom with mouse wheel / pinch</span>
        </div>
        <div class="right-actions">
          <button type="button" id="cancelCrop" class="small">Cancel</button>
          <button type="button" id="confirmCrop" class="small">Crop & Use</button>
        </div>
      </div>
    </div>
  </div>

  <script>
    // ======= CONFIG =======
    const GAS_URL = "https://script.google.com/macros/s/AKfycbwoijzTp_nlEfdXawiLNxPXu0e5sH9qM5FOSJFkzJVoUA0kGZjRAbZAcM1wUJmRwMuC/exec"; // must end with /exec

    // ======= DOM/State =======
    const $ = (id) => document.getElementById(id);
    const stickerInput = $("sticker");
    const mcInput = $("mcfile");
    const stickerPreview = $("stickerPreview");
    const mcPreview = $("mcPreview");
    const ocrBox = $("ocrResult");
    const statusBox = $("status");
    const submitBtn = $("submitBtn");
    const cropModal = $("cropModal");
    const cropImage = $("cropImage");
    const cropTitle = $("cropTitle");
    const cropStickerBtn = $("cropStickerBtn");
    const cropMcBtn = $("cropMcBtn");
    const rotateLeftBtn = $("rotateLeft");
    const rotateRightBtn = $("rotateRight");
    const resetCropBtn = $("resetCrop");
    const cancelCropBtn = $("cancelCrop");
    const confirmCropBtn = $("confirmCrop");
    const nameManual = $("nameManual");
    const mrnManual = $("mrnManual");

    let cropper = null;
    let cropTarget = null; // "sticker" | "mc"
    let stickerCroppedBlob = null;
    let mcCroppedBlob = null;

    function setStatus(msg, ok=false, err=false){
      statusBox.textContent = msg;
      statusBox.className = "log" + (ok ? " ok" : "") + (err ? " err" : "");
    }

    function showPreviewFromFile(input, imgEl){
      const f = input.files?.[0];
      if (!f) { imgEl.src = ""; imgEl.alt = ""; return; }
      const url = URL.createObjectURL(f);
      imgEl.onerror = () => {
        console.error("Preview failed. Type:", f.type, "Name:", f.name);
        imgEl.alt = "Preview failed to load";
      };
      imgEl.src = url;
      imgEl.onload = () => URL.revokeObjectURL(url);
    }

    // HEIC -> JPEG
    async function normalizeImageFile(file) {
      if (/image\/hei(c|f)/i.test(file.type) || /\.hei(c|f)$/i.test(file.name)) {
        try {
          const result = await heic2any({ blob: file, toType: "image/jpeg", quality: 0.92 });
          const blob = Array.isArray(result) ? result[0] : result;
          return new File([blob], (file.name.replace(/\.[^\.]+$/, '') || 'image') + ".jpg", { type: "image/jpeg" });
        } catch (e) {
          console.error("HEIC conversion failed:", e);
          throw new Error("HEIC conversion failed. Use JPEG/PNG or set iPhone Camera → Formats → Most Compatible.");
        }
      }
      return file;
    }

    // Hook file inputs (normalize => preview)
    stickerInput.addEventListener("change", async () => {
      if (!stickerInput.files[0]) return;
      const normalized = await normalizeImageFile(stickerInput.files[0]);
      if (normalized !== stickerInput.files[0]) {
        const dt = new DataTransfer(); dt.items.add(normalized);
        stickerInput.files = dt.files;
      }
      showPreviewFromFile(stickerInput, stickerPreview);
      stickerCroppedBlob = null;
    });

    mcInput.addEventListener("change", async () => {
      if (!mcInput.files[0]) return;
      const normalized = await normalizeImageFile(mcInput.files[0]);
      if (normalized !== mcInput.files[0]) {
        const dt = new DataTransfer(); dt.items.add(normalized);
        mcInput.files = dt.files;
      }
      showPreviewFromFile(mcInput, mcPreview);
      mcCroppedBlob = null;
    });

    // Cropper
    function openCropperFor(input, title){
      const file = input.files?.[0];
      if (!file) { alert("Please choose a file first."); return; }
      cropTitle.textContent = title;

      const url = URL.createObjectURL(file);
      cropImage.src = url;
      cropImage.onload = () => {
        if (cropper) { cropper.destroy(); cropper = null; }
        cropper = new Cropper(cropImage, {
          viewMode: 1,
          autoCropArea: 0.9,
          responsive: true,
          movable: true,
          zoomable: true,
          rotatable: true,
          background: false
        });
      };

      cropTarget = (input === stickerInput) ? "sticker" : "mc";
      cropModal.classList.add("open");
    }

    cropStickerBtn.addEventListener("click", () => openCropperFor(stickerInput, "Crop Sticker (focus on Name & MRN barcode)"));
    cropMcBtn.addEventListener("click", () => openCropperFor(mcInput, "Crop Medical Certificate"));

    rotateLeftBtn.addEventListener("click", () => cropper?.rotate(-90));
    rotateRightBtn.addEventListener("click", () => cropper?.rotate(90));
    resetCropBtn.addEventListener("click", () => cropper?.reset());
    cancelCropBtn.addEventListener("click", () => {
      cropModal.classList.remove("open");
      if (cropper) { cropper.destroy(); cropper = null; }
    });

    confirmCropBtn.addEventListener("click", () => {
      if (!cropper) return;
      const canvas = cropper.getCroppedCanvas({ maxWidth: 4096, maxHeight: 4096 });
      canvas.toBlob((blob) => {
        if (!blob) { alert("Failed to crop image."); return; }
        if (cropTarget === "sticker") {
          stickerCroppedBlob = blob;
          const url = URL.createObjectURL(blob);
          stickerPreview.src = url;
          stickerPreview.onload = () => URL.revokeObjectURL(url);
        } else {
          mcCroppedBlob = blob;
          const url = URL.createObjectURL(blob);
          mcPreview.src = url;
          mcPreview.onload = () => URL.revokeObjectURL(url);
        }
        cropModal.classList.remove("open");
        cropper.destroy(); cropper = null;
      }, "image/jpeg", 0.92);
    });

    // OCR helpers
    function fileOrBlobToBase64(obj) {
      return new Promise((resolve, reject) => {
        const fr = new FileReader();
        fr.onload = () => resolve(String(fr.result).split(",")[1] || "");
        fr.onerror = reject;
        fr.readAsDataURL(obj);
      });
    }

    async function runStickerOCR(blobOrFile){
      try {
        const { createWorker } = Tesseract;
        const worker = await createWorker({ logger: () => {} });
        await worker.loadLanguage("eng");
        await worker.initialize("eng");
        const res = await worker.recognize(blobOrFile);
        await worker.terminate();
        return (res?.data?.text) || "";
      } catch (e) {
        console.error("OCR failed:", e);
        return "";
      }
    }

    function extractNameFromText(text) {
      const cleaned = (text || "")
        .replace(/[^\x09\x0A\x0D\x20-\x7E]/g,' ')
        .replace(/\u200B/g,'')
        .replace(/\s{2,}/g,' ')
        .trim();
      const lines = cleaned.split(/\r?\n/).map(s => s.trim()).filter(Boolean);
      return lines.length ? lines[0] : null;
    }

    // Barcode MRN (native)
    async function extractMrnFromBarcode(blobOrFile) {
      const result = { mrn: null, raw: null, digits: null };
      try {
        if (!("BarcodeDetector" in window)) return result;

        let formats = [];
        try { formats = await BarcodeDetector.getSupportedFormats(); } catch (_) {}
        const wanted = ['code_128','code_39','code_93','codabar','itf','ean_13','ean_8','pdf417','qr_code','aztec','data_matrix'];
        const fmts = formats.length ? wanted.filter(f => formats.includes(f)) : wanted;

        const detector = new BarcodeDetector({ formats: fmts });
        const bitmap = await createImageBitmap(blobOrFile);
        const codes = await detector.detect(bitmap);
        if (codes && codes.length) {
          const values = codes.map(c => String(c.rawValue || '').trim()).filter(Boolean);
          if (values.length) {
            result.raw = values[0];
            const upm = values.map(v => (v.match(/\b(UPM\d{6,12})\b/i) || [])[1]).find(Boolean);
            if (upm) result.mrn = upm.toUpperCase();
            const digits = values.map(v => (v.match(/\b(\d{6,12})\b/) || [])[1]).find(Boolean);
            if (digits) result.digits = digits;
          }
        }
      } catch (e) {
        console.error("Barcode detection failed:", e);
      }
      return result;
    }

    // Submit
    document.getElementById("mcForm").addEventListener("submit", onSubmit);

    async function onSubmit(e){
      e.preventDefault();
      const zone = document.getElementById("zone").value;
      const stickerFile = stickerInput.files[0];
      const mcFile = mcInput.files[0];

      if (!zone || !stickerFile || !mcFile) {
        alert("Please complete all fields.");
        return;
      }

      // Prefer cropped blobs if available
      const stickerForOcr = stickerCroppedBlob || stickerFile;
      const mcForUpload   = mcCroppedBlob || mcFile;

      setStatus("Reading barcode for MRN…");
      const barcode = await extractMrnFromBarcode(stickerForOcr);

      setStatus("Running OCR on (cropped) sticker…");
      let ocrText = await runStickerOCR(stickerForOcr);

      // Name from OCR; MRN from barcode; allow manual overrides
      let name = extractNameFromText(ocrText);
      let mrn = barcode.mrn || null;

      if (mrnManual.value.trim())  mrn  = mrnManual.value.trim().toUpperCase();
      if (nameManual.value.trim()) name = nameManual.value.trim();

      // Fallback to OCR MRN if barcode not found
      if (!mrn) {
        const m = (ocrText || "").match(/\b(UPM\d{6,12})\b/i);
        if (m) mrn = m[1].toUpperCase();
      }

      setStatus("Uploading to Drive & writing to Sheet…");
      submitBtn.disabled = true;

      try {
        const [stickerB64, mcB64] = await Promise.all([
          fileOrBlobToBase64(stickerForOcr),
          fileOrBlobToBase64(mcForUpload)
        ]);

        const payload = {
          zone,
          ocrText,
          nameOverride: name || null,
          mrnOverride: mrn || null,
          barcodeRaw: barcode.raw || null,
          barcodeDigits: barcode.digits || null,
          sticker: { name: stickerFile.name, mime: "image/jpeg", b64: stickerB64 },
          mcfile:  { name: mcFile.name,     mime: "image/jpeg", b64: mcB64 }
        };

        const resp = await fetch(GAS_URL, { method: "POST", body: JSON.stringify(payload) });
        if (!resp.ok) {
          const txt = await resp.text();
          throw new Error(`HTTP ${resp.status} – ${txt.slice(0,200)}`);
        }
        const data = await resp.json();
        if (!data.ok) throw new Error(data.error || "Unknown server error");

        setStatus("Success ✔ Files uploaded & row added.", true);
        ocrBox.textContent = `Name=${data.name || name || "—"} | MRN=${data.mrn || mrn || "—"}\nSticker: ${data?.sticker?.url || "—"}\nMC: ${data?.mc?.url || "—"}`;
        alert("OK:\n" + JSON.stringify(data, null, 2));
      } catch (err) {
        console.error(err);
        setStatus("Failed: " + err.message, false, true);
        alert("Error:\n" + err.message);
      } finally {
        submitBtn.disabled = false;
      }
    }
  </script>
</body>
</html>
