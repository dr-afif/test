<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>MC Use – Fast Mobile</title>
  <style>
    :root { --gap: 12px; }
    * { box-sizing: border-box; }
    html, body { margin:0; padding:0; }
    body {
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      line-height: 1.35;
      color: #111;
      background: #fff;
      overflow-x: hidden;  /* no sideways scrolling */
    }
    .wrap {
      max-width: 680px;   /* narrow for phones */
      width: 100%;
      margin: 16px auto 60px;
      padding: 0 12px;
    }
    h2 { margin: 8px 0 6px; font-size: 1.25rem; }
    .muted { color:#666; font-size:.92rem; margin-bottom: 10px; }

    fieldset { border: 1px solid #e5e5e5; border-radius: 10px; padding: 12px; }
    label { display:block; margin: 10px 0 6px; font-weight: 600; }
    select, input[type=file], input[type=text], button {
      display:block; width: 100%; font-size: 16px; padding: 10px; border-radius: 10px;
      border: 1px solid #d7d7d7; background:#fff;
    }
    input[type=file] { padding: 8px; }
    button {
      background:#0a7a2f; color:#fff; border:none; font-weight:600;
    }
    button:disabled { opacity:.6; }

    .grid { display: grid; grid-template-columns: 1fr; gap: var(--gap); }
    /* On big screens we show two columns; phones stay 1 column */
    @media (min-width: 900px) { .grid.two { grid-template-columns: 1fr 1fr; } }

    .preview {
      width: 100%; height: auto; max-height: 240px;
      border: 1px dashed #cfcfcf; border-radius: 10px; object-fit: contain;
      background: #fafafa;
    }

    .log {
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      font-size: .95rem; white-space: pre-wrap;
      background: #fafafa; border: 1px solid #eee;
      border-radius: 10px; padding: 10px;
    }
    .ok{color:#0a7a2f}.err{color:#b00020}

    .row { display:flex; gap: var(--gap); }
    .row > * { flex: 1; }
  </style>

  <!-- OCR -->
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@4/dist/tesseract.min.js"></script>
  <!-- HEIC -> JPEG -->
  <script src="https://cdn.jsdelivr.net/npm/heic2any@0.0.4/dist/heic2any.min.js"></script>
  <!-- Barcode fallback (if native API not available) -->
  <script src="https://cdn.jsdelivr.net/npm/quagga2@1.8.4/dist/quagga.min.js"></script>
</head>
<body>
  <div class="wrap">
    <h2>Medical Certificate (MC) Use</h2>
    <p class="muted">Mobile-friendly. Sticker is processed locally (not uploaded). Only the MC photo is saved to Drive.</p>

    <form id="mcForm">
      <fieldset>
        <label for="zone">Zone</label>
        <select id="zone" required>
          <option value="">— Select —</option>
          <option>Green</option>
          <option>Yellow</option>
          <option>Red</option>
        </select>

        <div class="grid two">
          <div>
            <label for="sticker">Patient sticker photo (local only)</label>
            <input type="file" id="sticker" accept="image/*" capture="environment" required />
            <img id="stickerPreview" class="preview" alt="">
            <div class="muted">Point-and-shoot. We auto-detect the name and barcode — no cropping needed.</div>
          </div>
          <div>
            <label for="mcfile">Medical Certificate photo (saved)</label>
            <input type="file" id="mcfile" accept="image/*" capture="environment" required />
            <img id="mcPreview" class="preview" alt="">
          </div>
        </div>

        <div class="grid two" style="margin-top: var(--gap)">
          <div>
            <label>Detected</label>
            <div id="parsed" class="log">— waiting —</div>
          </div>
          <div>
            <label>Manual override (optional)</label>
            <input type="text" id="nameManual" placeholder="Name (override)">
            <input type="text" id="mrnManual" placeholder="MRN (UPMxxxxxxxxx)">
          </div>
        </div>

        <div style="margin-top: var(--gap)">
          <button id="submitBtn" type="submit">Submit</button>
        </div>
      </fieldset>
    </form>

    <div style="margin-top: var(--gap)">
      <div id="status" class="log">Status: idle</div>
    </div>
  </div>

  <script>
    /* ===== CONFIG ===== */
    const GAS_URL = "https://script.google.com/macros/s/AKfycbwoijzTp_nlEfdXawiLNxPXu0e5sH9qM5FOSJFkzJVoUA0kGZjRAbZAcM1wUJmRwMuC/exec"; // /exec URL
    const MAX_DIM = 1100;            // resize long edge for speed
    const OCR_TIMEOUT_MS = 6000;     // hard timeout so nothing hangs
    const BARCODE_TIMEOUT_MS = 3500; // hard timeout for barcode

    /* ===== DOM ===== */
    const $ = id => document.getElementById(id);
    const zoneEl = $("zone");
    const stickerEl = $("sticker");
    const mcEl = $("mcfile");
    const stickerPreview = $("stickerPreview");
    const mcPreview = $("mcPreview");
    const statusEl = $("status");
    const parsedEl = $("parsed");
    const nameManual = $("nameManual");
    const mrnManual = $("mrnManual");
    const submitBtn = $("submitBtn");

    let stickerBlob = null, mcBlob = null;

    const setStatus = (msg, ok=false, err=false) => {
      statusEl.textContent = msg;
      statusEl.className = "log" + (ok ? " ok" : "") + (err ? " err" : "");
    };

    /* ===== Utilities (mobile-first, no sideways scroll) ===== */
    function showPreview(blob, imgEl){
      const url = URL.createObjectURL(blob);
      imgEl.src = url;
      imgEl.onload = () => URL.revokeObjectURL(url);
    }
    function fitWithin(w,h,max){ const s = Math.min(1, max/Math.max(w,h)); return { w:Math.round(w*s), h:Math.round(h*s) }; }
    function blobToImage(blob){ return new Promise((res,rej)=>{ const u=URL.createObjectURL(blob); const i=new Image(); i.onload=()=>{URL.revokeObjectURL(u); res(i)}; i.onerror=rej; i.src=u; }); }
    function blobToBase64(b){ return new Promise((res,rej)=>{ const fr=new FileReader(); fr.onload=()=>res(String(fr.result).split(",")[1]||""); fr.onerror=rej; fr.readAsDataURL(b); }); }

    async function normalize(file){
      // Convert HEIC to JPEG if needed
      if (/image\/hei(c|f)/i.test(file.type) || /\.hei(c|f)$/i.test(file.name)) {
        try {
          const r = await heic2any({ blob:file, toType:"image/jpeg", quality:0.92 });
          file = new File([Array.isArray(r)?r[0]:r], (file.name.replace(/\.[^\.]+$/, '')||'image')+".jpg", { type:"image/jpeg" });
        } catch(e) {
          alert("HEIC conversion failed. Please set iPhone Camera → Formats → Most Compatible.");
          throw e;
        }
      }
      // Resize for speed
      const img = await blobToImage(file);
      const { w, h } = fitWithin(img.naturalWidth||img.width, img.naturalHeight||img.height, MAX_DIM);
      const can = document.createElement("canvas"); can.width = w; can.height = h;
      const ctx = can.getContext("2d"); ctx.drawImage(img,0,0,w,h);
      const blob = await new Promise(r => can.toBlob(r, "image/jpeg", 0.85));
      return blob;
    }

    function withTimeout(promise, ms){
      let t; return Promise.race([
        promise.finally(()=>clearTimeout(t)),
        new Promise(r=>{ t=setTimeout(()=>r(null), ms); })
      ]);
    }

    /* ===== Auto-ROI (works even if sticker has background) =====
       We compute the bottom 45% for barcode and top 40% for the name.
       Because users may include background, we clamp inside the actual image,
       so it's robust even when the sticker doesn't fill the frame. */
    async function roi(blob, topFrac, bottomFrac){
      const img = await blobToImage(blob);
      const W = img.naturalWidth||img.width, H = img.naturalHeight||img.height;
      const y0 = Math.max(0, Math.floor(H * topFrac));
      const y1 = Math.min(H, Math.floor(H * bottomFrac));
      const hh = Math.max(1, y1 - y0);
      const can = document.createElement("canvas"); can.width = W; can.height = hh;
      const ctx = can.getContext("2d"); ctx.drawImage(img, 0, y0, W, hh, 0, 0, W, hh);
      return await new Promise(r => can.toBlob(r, "image/jpeg", 0.9));
    }

    /* ===== Barcode (native first, Quagga fallback) ===== */
    async function nativeBarcodeDetect(blob){
      if (!("BarcodeDetector" in window)) return null;
      try {
        const detector = new BarcodeDetector({ formats:['code_128','code_39','code_93','itf','codabar','ean_13','ean_8','pdf417'] });
        const bmp = await createImageBitmap(blob);
        const codes = await detector.detect(bmp);
        if (codes?.length) return String(codes[0].rawValue||"").trim();
      } catch(_) {}
      return null;
    }
    function quaggaDecodeBlob(blob){
      return new Promise(resolve=>{
        const url = URL.createObjectURL(blob);
        Quagga.decodeSingle({
          src: url, numOfWorkers: 0, locate: true,
          inputStream: { size: 1024 },
          locator: { halfSample: true, patchSize: "large" },
          decoder: { readers: ["code_128_reader","code_39_reader","code_93_reader","i2of5_reader","codabar_reader"] }
        }, res => { URL.revokeObjectURL(url); resolve(res?.codeResult?.code ? String(res.codeResult.code) : null); });
        // Safety net in case Quagga never calls back
        setTimeout(()=>{ try{URL.revokeObjectURL(url);}catch{} resolve(null); }, BARCODE_TIMEOUT_MS - 100);
      });
    }
    function normalizeMrn(raw){
      if (!raw) return null;
      const upm = (raw.match(/\b(UPM\d{6,12})\b/i)||[])[1];
      if (upm) return upm.toUpperCase();
      const digits = (raw.match(/\b(\d{6,12})\b/)||[])[1];
      return digits ? ("UPM"+digits) : null;
    }
    async function extractMrnFrom(blob){
      const barcodeROI = await roi(blob, 0.55, 1.0);  // bottom 45%
      let raw = await withTimeout(nativeBarcodeDetect(barcodeROI), BARCODE_TIMEOUT_MS);
      let mrn = normalizeMrn(raw);
      if (mrn) return { mrn, raw };
      raw = await withTimeout(quaggaDecodeBlob(barcodeROI), BARCODE_TIMEOUT_MS);
      mrn = normalizeMrn(raw);
      return { mrn, raw };
    }

    /* ===== OCR (Name — single line, uppercase, no digits) ===== */
    async function runNameOCR(blob){
      const nameROI = await roi(blob, 0.0, 0.40);    // top 40%
      try {
        const { createWorker } = Tesseract;
        const worker = await createWorker({ logger: () => {} });
        await worker.loadLanguage("eng");
        await worker.initialize("eng");
        await worker.setParameters({
          tessedit_char_whitelist: "ABCDEFGHIJKLMNOPQRSTUVWXYZ @'-.",
          preserve_interword_spaces: "1",
          tessedit_pageseg_mode: "6"  // assume a block
        });
        const res = await withTimeout(worker.recognize(nameROI), OCR_TIMEOUT_MS);
        await worker.terminate();
        if (!res) return ""; // timeout
        const lines = String(res.data?.text || "").toUpperCase().split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
        const candidate = lines.find(t => t && !/\d/.test(t)) || "";
        return candidate.replace(/^[^A-Z0-9]+|[^A-Z0-9 @'\.-]+$/g,'').trim();
      } catch(_) { return ""; }
    }

    /* ===== Input hooks ===== */
    stickerEl.addEventListener("change", async () => {
      if (!stickerEl.files[0]) return;
      setStatus("Processing sticker…");
      stickerBlob = await normalize(stickerEl.files[0]);
      showPreview(stickerBlob, stickerPreview);

      // Auto-detect in the background (fast)
      setStatus("Detecting from sticker…");
      const [mrnRes, nameRes] = await Promise.all([
        extractMrnFrom(stickerBlob).catch(()=>({mrn:null})),
        runNameOCR(stickerBlob).catch(()=>(""))
      ]);

      const name = nameRes || "";
      const mrn  = mrnRes?.mrn || "";
      parsedEl.textContent = `Name=${name || "—"} | MRN=${mrn || "—"}`;
      setStatus("Sticker processed", true);
    });

    mcEl.addEventListener("change", async () => {
      if (!mcEl.files[0]) return;
      setStatus("Processing MC photo…");
      mcBlob = await normalize(mcEl.files[0]);
      showPreview(mcBlob, mcPreview);
      setStatus("MC ready", true);
    });

    /* ===== Submit (MC only is uploaded) ===== */
    document.getElementById("mcForm").addEventListener("submit", onSubmit);

    async function onSubmit(e){
      e.preventDefault();
      if (!zoneEl.value || !stickerEl.files[0] || !mcEl.files[0]) {
        alert("Please complete all fields."); return;
      }
      if (!stickerBlob) stickerBlob = await normalize(stickerEl.files[0]);
      if (!mcBlob) mcBlob = await normalize(mcEl.files[0]);

      setStatus("Finalizing fields…");
      // Ensure we have values (re-run quickly with timeouts)
      const [mrnRes, nameRes] = await Promise.all([
        extractMrnFrom(stickerBlob).catch(()=>({mrn:null,raw:null})),
        runNameOCR(stickerBlob).catch(()=>(""))
      ]);
      let name = nameManual.value.trim() || nameRes || "";
      let mrn  = (mrnManual.value.trim().toUpperCase()) || mrnRes.mrn || "";

      parsedEl.textContent = `Name=${name || "—"} | MRN=${mrn || "—"}`;

      setStatus("Uploading MC & writing row…");
      submitBtn.disabled = true;
      try {
        const mcB64 = await blobToBase64(mcBlob);  // ONLY MC is sent
        const payload = {
          zone: zoneEl.value,
          nameOverride: name || null,
          mrnOverride: mrn || null,
          // for debugging if needed:
          // ocrText: nameRes, barcodeRaw: mrnRes.raw || null,
          mcfile: { name: mcEl.files[0].name, mime: "image/jpeg", b64: mcB64 }
        };

        const resp = await fetch(GAS_URL, { method: "POST", body: JSON.stringify(payload) });
        if (!resp.ok) { const txt = await resp.text(); throw new Error(`HTTP ${resp.status} – ${txt.slice(0,200)}`); }
        const data = await resp.json();
        if (!data.ok) throw new Error(data.error || "Unknown server error");

        setStatus("Success ✔ Files uploaded & row added.", true);
        parsedEl.textContent = `Name=${data.name || name || "—"} | MRN=${data.mrn || mrn || "—"}\nMC: ${data?.mc?.url || "—"}`;
      } catch (err) {
        console.error(err);
        setStatus("Failed: " + err.message, false, true);
        alert("Error:\n" + err.message);
      } finally {
        submitBtn.disabled = false;
      }
    }
  </script>
</body>
</html>
