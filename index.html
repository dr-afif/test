<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>MC Use – Test (Auto-detect, Fast)</title>
  <style>
    body { font-family: system-ui, Arial; max-width: 900px; margin: 2rem auto; padding: 0 1rem; }
    h2 { margin-bottom: .75rem; }
    fieldset { border: 1px solid #ddd; padding: 1rem; border-radius: .5rem; }
    label { display: block; margin: .6rem 0 .3rem; }
    select, input[type=file], input[type=text], button { padding: .5rem; font-size: 1rem; }
    .row-2 { display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; }
    .muted { color: #666; font-size: .9rem; }
    .preview { margin-top: .5rem; max-width: 100%; max-height: 220px; border: 1px dashed #bbb; border-radius: .4rem; object-fit: contain; }
    .log { background:#f7f7f7; border:1px solid #eee; padding:.5rem .75rem; border-radius:.4rem; white-space:pre-wrap; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
    .ok { color: #0a7a2f; }
    .err { color: #b00020; }
    .btn-row { display:flex; gap:.5rem; flex-wrap: wrap; margin-top:.4rem; }
    .small { font-size:.9rem; padding:.35rem .6rem; }
    .hint { font-size:.85rem; color:#555; }
  </style>

  <!-- OCR -->
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@4/dist/tesseract.min.js"></script>
  <!-- HEIC -> JPEG -->
  <script src="https://cdn.jsdelivr.net/npm/heic2any@0.0.4/dist/heic2any.min.js"></script>
  <!-- Quagga2 (barcode fallback) -->
  <script src="https://cdn.jsdelivr.net/npm/quagga2@1.8.4/dist/quagga.min.js"></script>
</head>
<body>
  <h2>Medical Certificate (MC) Use – Test</h2>
  <p class="muted">Just take photos. The page auto-detects MRN from the barcode and Name from the top-line text. iPhone HEIC is converted. Images are compressed for speed.</p>

  <form id="mcForm">
    <fieldset>
      <label for="zone">Zone</label>
      <select id="zone" required>
        <option value="">— Select —</option>
        <option>Green</option>
        <option>Yellow</option>
        <option>Red</option>
      </select>

      <div class="row-2">
        <div>
          <label for="sticker">Patient sticker photo</label>
          <input type="file" id="sticker" accept="image/*" capture="environment" required />
          <img id="stickerPreview" class="preview" alt="">
          <div class="hint">Tip: keep the sticker flat, well-lit, and fill the frame.</div>
        </div>

        <div>
          <label for="mcfile">Medical Certificate photo</label>
          <input type="file" id="mcfile" accept="image/*" capture="environment" required />
          <img id="mcPreview" class="preview" alt="">
        </div>
      </div>

      <div class="row-2">
        <div>
          <label>Parsed</label>
          <div id="ocrResult" class="log muted">— waiting —</div>
        </div>
        <div>
          <label>Manual override (optional)</label>
          <input type="text" id="nameManual" placeholder="Name (override)">
          <input type="text" id="mrnManual" placeholder="MRN (UPMxxxxxxxxx)">
          <div class="hint">If filled, these override auto-detected values.</div>
        </div>
      </div>

      <div style="margin-top:1rem" class="btn-row">
        <button id="submitBtn" type="submit">Submit</button>
      </div>
    </fieldset>
  </form>

  <div style="margin-top:1rem">
    <div id="status" class="log">Status: idle</div>
  </div>

  <script>
    /* ======= CONFIG ======= */
    const GAS_URL = "https://script.google.com/macros/s/AKfycbwoijzTp_nlEfdXawiLNxPXu0e5sH9qM5FOSJFkzJVoUA0kGZjRAbZAcM1wUJmRwMuC/exec"; // must end with /exec
    const MAX_DIMENSION = 1400; // px (resize for speed)

    /* ======= DOM ======= */
    const $ = (id) => document.getElementById(id);
    const stickerInput = $("sticker");
    const mcInput = $("mcfile");
    const stickerPreview = $("stickerPreview");
    const mcPreview = $("mcPreview");
    const ocrBox = $("ocrResult");
    const statusBox = $("status");
    const submitBtn = $("submitBtn");
    const nameManual = $("nameManual");
    const mrnManual = $("mrnManual");

    function setStatus(msg, ok=false, err=false){
      statusBox.textContent = msg;
      statusBox.className = "log" + (ok ? " ok" : "") + (err ? " err" : "");
    }

    function showPreview(blob, imgEl){
      const url = URL.createObjectURL(blob);
      imgEl.src = url;
      imgEl.onload = () => URL.revokeObjectURL(url);
    }

    // HEIC->JPEG + resize + orient
    async function normalizeAndResize(file) {
      // Convert HEIC/HEIF to JPEG
      if (/image\/hei(c|f)/i.test(file.type) || /\.hei(c|f)$/i.test(file.name)) {
        const result = await heic2any({ blob: file, toType: "image/jpeg", quality: 0.92 });
        file = new File([Array.isArray(result) ? result[0] : result], (file.name.replace(/\.[^\.]+$/, '') || 'image') + ".jpg", { type: "image/jpeg" });
      }
      // Draw to canvas & downscale
      const img = await blobToImage(file);
      const { w, h } = fitWithin(img.naturalWidth || img.width, img.naturalHeight || img.height, MAX_DIMENSION);
      const canvas = document.createElement("canvas");
      canvas.width = w; canvas.height = h;
      const ctx = canvas.getContext("2d");
      ctx.drawImage(img, 0, 0, w, h);
      const blob = await new Promise(r => canvas.toBlob(r, "image/jpeg", 0.85));
      return blob;
    }
    function fitWithin(w, h, max){
      const scale = Math.min(1, max / Math.max(w, h));
      return { w: Math.round(w*scale), h: Math.round(h*scale) };
    }
    function blobToImage(blob){ return new Promise((res, rej) => { const u = URL.createObjectURL(blob); const i = new Image(); i.onload = () => { URL.revokeObjectURL(u); res(i); }; i.onerror = rej; i.src = u; }); }
    function blobToBase64(b){ return new Promise((res, rej) => { const fr = new FileReader(); fr.onload = () => res(String(fr.result).split(",")[1]||""); fr.onerror = rej; fr.readAsDataURL(b); }); }

    // Hook inputs: normalize & preview
    let stickerBlob = null, mcBlob = null; // compressed blobs used for detection & upload

    stickerInput.addEventListener("change", async () => {
      if (!stickerInput.files[0]) return;
      setStatus("Processing sticker photo…");
      stickerBlob = await normalizeAndResize(stickerInput.files[0]);
      showPreview(stickerBlob, stickerPreview);
      setStatus("Sticker ready", true);
      autoParsePreview(); // try extracting immediately
    });

    mcInput.addEventListener("change", async () => {
      if (!mcInput.files[0]) return;
      setStatus("Processing MC photo…");
      mcBlob = await normalizeAndResize(mcInput.files[0]);
      showPreview(mcBlob, mcPreview);
      setStatus("MC ready", true);
    });

    // Auto-parse on stickerBlob
    async function autoParsePreview(){
      if (!stickerBlob) return;
      setStatus("Detecting barcode + OCR…");

      const [barcode, nameOcr] = await Promise.all([
        extractMrnFromBarcode(stickerBlob),
        runNameOCR(stickerBlob)
      ]);

      const name = nameManual.value.trim() || nameOcr || "";
      const mrn  = mrnManual.value.trim().toUpperCase() || barcode.mrn || extractMrnFromOCR(nameOcr) || "";

      ocrBox.textContent = `Name=${name || "—"} | MRN=${mrn || "—"}`;
      setStatus("Ready", true);
    }

    // ===== Barcode (native first, Quagga fallback) =====
    async function nativeBarcodeDetect(blobOrFile){
      if (!("BarcodeDetector" in window)) return null;
      try {
        const fmts = ['code_128','code_39','code_93','ean_13','ean_8','itf','codabar','pdf417'];
        const detector = new BarcodeDetector({ formats: fmts });
        const bmp = await createImageBitmap(blobOrFile);
        const codes = await detector.detect(bmp);
        if (codes && codes.length) return String(codes[0].rawValue || '').trim();
      } catch (e) { /* ignore */ }
      return null;
    }
    function quaggaDecodeFromBlob(blob){
      return new Promise((resolve) => {
        const url = URL.createObjectURL(blob);
        Quagga.decodeSingle({
          src: url,
          numOfWorkers: 0,
          locate: true,
          inputStream: { size: 1280 },
          locator: { halfSample: true, patchSize: "large" },
          decoder: { readers: ["code_128_reader", "code_39_reader", "code_93_reader", "i2of5_reader", "codabar_reader"] }
        }, (result) => {
          URL.revokeObjectURL(url);
          resolve(result?.codeResult?.code ? String(result.codeResult.code) : null);
        });
      });
    }
    function normalizeMrn(raw){
      if (!raw) return null;
      const upm = (raw.match(/\b(UPM\d{6,12})\b/i) || [])[1];
      if (upm) return upm.toUpperCase();
      const digits = (raw.match(/\b(\d{6,12})\b/) || [])[1];
      if (digits) return "UPM" + digits;
      return null;
    }
    async function extractMrnFromBarcode(blob){
      let raw = await nativeBarcodeDetect(blob);
      let mrn = normalizeMrn(raw);
      if (mrn) return { mrn, raw };
      raw = await quaggaDecodeFromBlob(blob);
      mrn = normalizeMrn(raw);
      return { mrn, raw };
    }
    function extractMrnFromOCR(text){
      const m = (text || "").match(/\b(UPM\d{6,12})\b/i);
      return m ? m[1].toUpperCase() : null;
    }

    // ===== OCR (auto-pick top name line) =====
    async function runNameOCR(blob){
      try {
        const { createWorker } = Tesseract;
        const worker = await createWorker({ logger: () => {} });
        await worker.loadLanguage("eng");
        await worker.initialize("eng");
        await worker.setParameters({
          tessedit_char_whitelist: "ABCDEFGHIJKLMNOPQRSTUVWXYZ @'-.",
          preserve_interword_spaces: "1",
          tessedit_pageseg_mode: "6" // Assume a block of text
        });
        const res = await worker.recognize(blob);
        await worker.terminate();

        const lines = (res?.data?.lines || []).slice().sort((a,b)=>a.bbox.y0 - b.bbox.y0);
        // choose earliest line with mostly letters/spaces and no digits
        let pick = null;
        for (const ln of lines) {
          const t = String(ln.text || "").toUpperCase().replace(/\s{2,}/g,' ').trim();
          if (!t) continue;
          if (/\d/.test(t)) continue;                // no digits in name
          if (!/^[A-Z][A-Z @'\.-]{3,}$/.test(t)) continue; // looks like uppercase name
          pick = t.replace(/^[^A-Z0-9]+|[^A-Z0-9 @'\.-]+$/g,'').trim();
          break;
        }
        // fallback: first non-empty, no-digit line
        if (!pick) {
          const all = String(res?.data?.text || "").toUpperCase().split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
          pick = all.find(t => t && !/\d/.test(t)) || "";
          pick = pick.replace(/^[^A-Z0-9]+|[^A-Z0-9 @'\.-]+$/g,'').trim();
        }
        return pick || "";
      } catch (e) {
        return "";
      }
    }

    // ===== Submit =====
    document.getElementById("mcForm").addEventListener("submit", onSubmit);

    async function onSubmit(e){
      e.preventDefault();
      const zone = document.getElementById("zone").value;
      if (!zone || !stickerInput.files[0] || !mcInput.files[0]) {
        alert("Please complete all fields.");
        return;
      }
      // Ensure blobs ready
      if (!stickerBlob) stickerBlob = await normalizeAndResize(stickerInput.files[0]);
      if (!mcBlob) mcBlob = await normalizeAndResize(mcInput.files[0]);

      setStatus("Extracting data…");
      const [barcode, nameOcr] = await Promise.all([
        extractMrnFromBarcode(stickerBlob),
        runNameOCR(stickerBlob)
      ]);

      let name = nameManual.value.trim() || nameOcr || "";
      let mrn  = mrnManual.value.trim().toUpperCase() || barcode.mrn || extractMrnFromOCR(nameOcr) || "";

      ocrBox.textContent = `Name=${name || "—"} | MRN=${mrn || "—"}`;

      setStatus("Uploading to Drive & writing to Sheet…");
      submitBtn.disabled = true;

      try {
        const [stickerB64, mcB64] = await Promise.all([ blobToBase64(stickerBlob), blobToBase64(mcBlob) ]);
        const payload = {
          zone,
          ocrText: nameOcr,
          nameOverride: name || null,
          mrnOverride: mrn || null,
          barcodeRaw: barcode.raw || null,
          sticker: { name: stickerInput.files[0].name, mime: "image/jpeg", b64: stickerB64 },
          mcfile:  { name: mcInput.files[0].name,     mime: "image/jpeg", b64: mcB64 }
        };

        const resp = await fetch(GAS_URL, { method: "POST", body: JSON.stringify(payload) });
        if (!resp.ok) { const txt = await resp.text(); throw new Error(`HTTP ${resp.status} – ${txt.slice(0,200)}`); }
        const data = await resp.json();
        if (!data.ok) throw new Error(data.error || "Unknown server error");

        setStatus("Success ✔ Files uploaded & row added.", true);
        ocrBox.textContent = `Name=${data.name || name || "—"} | MRN=${data.mrn || mrn || "—"}\nSticker: ${data?.sticker?.url || "—"}\nMC: ${data?.mc?.url || "—"}`;
      } catch (err) {
        console.error(err);
        setStatus("Failed: " + err.message, false, true);
        alert("Error:\n" + err.message);
      } finally {
        submitBtn.disabled = false;
      }
    }
  </script>
</body>
</html>
