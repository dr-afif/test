<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>MC Use – Test (Crop + HEIC + Barcode)</title>

  <style>
    body { font-family: system-ui, Arial; max-width: 900px; margin: 2rem auto; padding: 0 1rem; }
    h2 { margin-bottom: .75rem; }
    fieldset { border: 1px solid #ddd; padding: 1rem; border-radius: .5rem; }
    label { display: block; margin: .6rem 0 .3rem; }
    select, input[type=file], input[type=text], button { padding: .5rem; font-size: 1rem; }
    .row-2 { display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; }
    .muted { color: #666; font-size: .9rem; }
    .preview { margin-top: .5rem; max-width: 100%; max-height: 240px; border: 1px dashed #bbb; border-radius: .4rem; object-fit: contain; }
    .log { background:#f7f7f7; border:1px solid #eee; padding:.5rem .75rem; border-radius:.4rem; white-space:pre-wrap; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
    .ok { color: #0a7a2f; }
    .err { color: #b00020; }
    .btn-row { display:flex; gap:.5rem; flex-wrap: wrap; margin-top:.4rem; }
    .small { font-size:.9rem; padding:.35rem .6rem; }
    .hint { font-size:.85rem; color:#555; }
    .modal { position: fixed; inset: 0; background: rgba(0,0,0,0.5); display: none; align-items: center; justify-content: center; z-index: 1000; }
    .modal.open { display: flex; }
    .modal-card { background: #fff; padding: 1rem; border-radius: .6rem; max-width: 95vw; max-height: 90vh; width: 900px; display:flex; flex-direction: column; gap:.6rem; }
    .crop-wrap { flex:1; min-height: 360px; border:1px solid #ddd; position:relative; overflow:hidden; }
    .crop-wrap img { max-width: 100%; display:block; }
    .modal-actions { display:flex; flex-wrap: wrap; gap:.5rem; justify-content: space-between; align-items:center; }
    .left-actions, .right-actions { display:flex; gap:.5rem; align-items:center; }
  </style>

  <!-- OCR -->
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@4/dist/tesseract.min.js"></script>
  <!-- Cropper.js -->
  <link href="https://cdn.jsdelivr.net/npm/cropperjs@1.6.2/dist/cropper.min.css" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/cropperjs@1.6.2/dist/cropper.min.js"></script>
  <!-- HEIC -> JPEG -->
  <script src="https://cdn.jsdelivr.net/npm/heic2any@0.0.4/dist/heic2any.min.js"></script>
  <!-- Quagga2 (barcode fallback) -->
  <script src="https://cdn.jsdelivr.net/npm/quagga2@1.8.4/dist/quagga.min.js"></script>
</head>
<body>
  <h2>Medical Certificate (MC) Use – Test</h2>
  <p class="muted">Crop images before OCR & upload. iPhone HEIC is converted to JPEG. MRN comes from barcode (native or Quagga fallback).</p>

  <form id="mcForm">
    <fieldset>
      <label for="zone">Zone</label>
      <select id="zone" required>
        <option value="">— Select —</option>
        <option>Green</option>
        <option>Yellow</option>
        <option>Red</option>
      </select>

      <div class="row-2">
        <div>
          <label for="sticker">Patient sticker photo</label>
          <input type="file" id="sticker" accept="image/*" capture="environment" required />
          <div class="btn-row">
            <button type="button" id="cropStickerNameBtn" class="small">Crop sticker (Name line)</button>
            <button type="button" id="cropStickerBarcodeBtn" class="small">Crop sticker (Barcode)</button>
          </div>
          <img id="stickerPreview" class="preview" alt="">
          <div class="hint">Use the two crop buttons: one for the top **Name line**, one for the **barcode area**.</div>
        </div>

        <div>
          <label for="mcfile">Medical Certificate photo</label>
          <input type="file" id="mcfile" accept="image/*" capture="environment" required />
          <div class="btn-row">
            <button type="button" id="cropMcBtn" class="small">Crop MC</button>
          </div>
          <img id="mcPreview" class="preview" alt="">
        </div>
      </div>

      <div class="row-2">
        <div>
          <label>Parsed</label>
          <div id="ocrResult" class="log muted">— waiting —</div>
        </div>
        <div>
          <label>Manual override (optional)</label>
          <input type="text" id="nameManual" placeholder="Name (override)">
          <input type="text" id="mrnManual" placeholder="MRN (UPMxxxxxxxxx)">
          <div class="hint">If filled, these override OCR/barcode results.</div>
        </div>
      </div>

      <div style="margin-top:1rem" class="btn-row">
        <button id="submitBtn" type="submit">Submit test</button>
      </div>
    </fieldset>
  </form>

  <div style="margin-top:1rem">
    <div id="status" class="log">Status: idle</div>
  </div>

  <!-- Crop Modal -->
  <div id="cropModal" class="modal" aria-hidden="true">
    <div class="modal-card">
      <strong id="cropTitle">Crop Image</strong>
      <div class="crop-wrap">
        <img id="cropImage" alt="">
      </div>
      <div class="modal-actions">
        <div class="left-actions">
          <button type="button" id="rotateLeft" class="small">⟲ Rotate -90°</button>
          <button type="button" id="rotateRight" class="small">⟳ Rotate +90°</button>
          <button type="button" id="resetCrop" class="small">Reset</button>
          <span class="hint">Zoom with mouse wheel / pinch</span>
        </div>
        <div class="right-actions">
          <button type="button" id="cancelCrop" class="small">Cancel</button>
          <button type="button" id="confirmCrop" class="small">Crop & Use</button>
        </div>
      </div>
    </div>
  </div>

  <script>
    /* ======= CONFIG ======= */
    const GAS_URL = "https://script.google.com/macros/s/AKfycbwoijzTp_nlEfdXawiLNxPXu0e5sH9qM5FOSJFkzJVoUA0kGZjRAbZAcM1wUJmRwMuC/exec"; // must end with /exec

    /* ======= DOM/State ======= */
    const $ = (id) => document.getElementById(id);
    const stickerInput = $("sticker");
    const mcInput = $("mcfile");
    const stickerPreview = $("stickerPreview");
    const mcPreview = $("mcPreview");
    const ocrBox = $("ocrResult");
    const statusBox = $("status");
    const submitBtn = $("submitBtn");

    const cropModal = $("cropModal");
    const cropImage = $("cropImage");
    const cropTitle = $("cropTitle");
    const rotateLeftBtn = $("rotateLeft");
    const rotateRightBtn = $("rotateRight");
    const resetCropBtn = $("resetCrop");
    const cancelCropBtn = $("cancelCrop");
    const confirmCropBtn = $("confirmCrop");

    const cropStickerNameBtn = $("cropStickerNameBtn");
    const cropStickerBarcodeBtn = $("cropStickerBarcodeBtn");
    const cropMcBtn = $("cropMcBtn");

    const nameManual = $("nameManual");
    const mrnManual = $("mrnManual");

    let cropper = null;
    let cropTarget = null; // "name" | "barcode" | "mc"

    // Cropped blobs
    let stickerNameCroppedBlob = null;
    let stickerBarcodeCroppedBlob = null;
    let mcCroppedBlob = null;

    function setStatus(msg, ok=false, err=false){
      statusBox.textContent = msg;
      statusBox.className = "log" + (ok ? " ok" : "") + (err ? " err" : "");
    }

    function showPreviewFromFile(input, imgEl){
      const f = input.files?.[0];
      if (!f) { imgEl.src = ""; imgEl.alt = ""; return; }
      const url = URL.createObjectURL(f);
      imgEl.onerror = () => { console.error("Preview failed.", f.type, f.name); imgEl.alt = "Preview failed"; };
      imgEl.src = url;
      imgEl.onload = () => URL.revokeObjectURL(url);
    }

    // HEIC -> JPEG
    async function normalizeImageFile(file) {
      if (/image\/hei(c|f)/i.test(file.type) || /\.hei(c|f)$/i.test(file.name)) {
        const result = await heic2any({ blob: file, toType: "image/jpeg", quality: 0.92 });
        const blob = Array.isArray(result) ? result[0] : result;
        return new File([blob], (file.name.replace(/\.[^\.]+$/, '') || 'image') + ".jpg", { type: "image/jpeg" });
      }
      return file;
    }

    // Inputs
    stickerInput.addEventListener("change", async () => {
      if (!stickerInput.files[0]) return;
      const normalized = await normalizeImageFile(stickerInput.files[0]);
      if (normalized !== stickerInput.files[0]) {
        const dt = new DataTransfer(); dt.items.add(normalized);
        stickerInput.files = dt.files;
      }
      showPreviewFromFile(stickerInput, stickerPreview);
      stickerNameCroppedBlob = null;
      stickerBarcodeCroppedBlob = null;
    });

    mcInput.addEventListener("change", async () => {
      if (!mcInput.files[0]) return;
      const normalized = await normalizeImageFile(mcInput.files[0]);
      if (normalized !== mcInput.files[0]) {
        const dt = new DataTransfer(); dt.items.add(normalized);
        mcInput.files = dt.files;
      }
      showPreviewFromFile(mcInput, mcPreview);
      mcCroppedBlob = null;
    });

    // Cropper
    function openCropperFor(inputFile, title, targetKey){
      const file = inputFile;
      if (!file) { alert("Please choose a file first."); return; }
      cropTitle.textContent = title;
      const url = URL.createObjectURL(file);
      cropImage.src = url;
      cropImage.onload = () => {
        if (cropper) { cropper.destroy(); cropper = null; }
        cropper = new Cropper(cropImage, {
          viewMode: 1,
          autoCropArea: 0.9,
          responsive: true,
          movable: true,
          zoomable: true,
          rotatable: true,
          background: false
        });
      };
      cropTarget = targetKey;
      cropModal.classList.add("open");
    }

    cropStickerNameBtn.addEventListener("click", () => {
      const f = stickerInput.files?.[0];
      if (!f) return alert("Pick sticker photo first.");
      openCropperFor(f, "Crop Sticker (Name line only)", "name");
    });

    cropStickerBarcodeBtn.addEventListener("click", () => {
      const f = stickerInput.files?.[0];
      if (!f) return alert("Pick sticker photo first.");
      openCropperFor(f, "Crop Sticker (Barcode area)", "barcode");
    });

    cropMcBtn.addEventListener("click", () => {
      const f = mcInput.files?.[0];
      if (!f) return alert("Pick MC photo first.");
      openCropperFor(f, "Crop Medical Certificate", "mc");
    });

    rotateLeftBtn.addEventListener("click", () => cropper?.rotate(-90));
    rotateRightBtn.addEventListener("click", () => cropper?.rotate(90));
    resetCropBtn.addEventListener("click", () => cropper?.reset());
    cancelCropBtn.addEventListener("click", () => {
      cropModal.classList.remove("open");
      if (cropper) { cropper.destroy(); cropper = null; }
    });

    confirmCropBtn.addEventListener("click", () => {
      if (!cropper) return;
      const canvas = cropper.getCroppedCanvas({ maxWidth: 4096, maxHeight: 4096 });
      canvas.toBlob((blob) => {
        if (!blob) { alert("Failed to crop image."); return; }
        if (cropTarget === "name") {
          stickerNameCroppedBlob = blob;
          const url = URL.createObjectURL(blob);
          stickerPreview.src = url; stickerPreview.onload = () => URL.revokeObjectURL(url);
        } else if (cropTarget === "barcode") {
          stickerBarcodeCroppedBlob = blob;
        } else if (cropTarget === "mc") {
          mcCroppedBlob = blob;
          const url = URL.createObjectURL(blob);
          mcPreview.src = url; mcPreview.onload = () => URL.revokeObjectURL(url);
        }
        cropModal.classList.remove("open");
        cropper.destroy(); cropper = null;
      }, "image/jpeg", 0.95);
    });

    // Helpers
    function fileOrBlobToBase64(obj) {
      return new Promise((resolve, reject) => {
        const fr = new FileReader();
        fr.onload = () => resolve(String(fr.result).split(",")[1] || "");
        fr.onerror = reject;
        fr.readAsDataURL(obj);
      });
    }

    async function runNameOCR(blobOrFile){
      try {
        const { createWorker } = Tesseract;
        const worker = await createWorker({ logger: () => {} });
        await worker.loadLanguage("eng");
        await worker.initialize("eng");
        await worker.setParameters({
          tessedit_char_whitelist: "ABCDEFGHIJKLMNOPQRSTUVWXYZ ' - @ .",
          preserve_interword_spaces: "1",
          // Try single line if you cropped only the name line:
          tessedit_pageseg_mode: "7" // SINGLE_LINE
        });
        const res = await worker.recognize(blobOrFile);
        await worker.terminate();
        let text = (res?.data?.text || "").toUpperCase().replace(/\s{2,}/g,' ').trim();
        // Clean leading/trailing junk
        text = text.replace(/^[^A-Z0-9]+|[^A-Z0-9 '@\.-]+$/g,'').trim();
        return text || "";
      } catch (e) {
        console.error("OCR failed:", e);
        return "";
      }
    }

    async function nativeBarcodeDetect(blobOrFile){
      if (!("BarcodeDetector" in window)) return null;
      try {
        const fmts = ['code_128','code_39','code_93','ean_13','ean_8','itf','codabar','pdf417'];
        const detector = new BarcodeDetector({ formats: fmts });
        const bmp = await createImageBitmap(blobOrFile);
        const codes = await detector.detect(bmp);
        if (codes && codes.length) return String(codes[0].rawValue || '').trim();
      } catch (e) { console.warn("Native barcode failed:", e); }
      return null;
    }

    function normalizeMrn(raw){
      if (!raw) return null;
      const upm = (raw.match(/\b(UPM\d{6,12})\b/i) || [])[1];
      if (upm) return upm.toUpperCase();
      const digits = (raw.match(/\b(\d{6,12})\b/) || [])[1];
      if (digits) return "UPM" + digits;
      return null;
    }

    function quaggaDecodeFromBlob(blob){
      return new Promise((resolve) => {
        const url = URL.createObjectURL(blob);
        // Quagga parameters tuned for still images
        Quagga.decodeSingle({
          src: url,
          numOfWorkers: 0, // in-browser single thread for local file
          locate: true,
          inputStream: { size: 1280 },
          locator: { halfSample: false, patchSize: "medium" },
          decoder: {
            readers: [
              "code_128_reader", "code_39_reader", "code_93_reader",
              "ean_reader", "ean_8_reader", "i2of5_reader", "codabar_reader"
            ]
          }
        }, (result) => {
          URL.revokeObjectURL(url);
          if (result && result.codeResult && result.codeResult.code) {
            resolve(String(result.codeResult.code));
          } else {
            resolve(null);
          }
        });
      });
    }

    async function extractMrnFromBarcode(blobOrFile){
      // 1) Try native
      let raw = await nativeBarcodeDetect(blobOrFile);
      let mrn = normalizeMrn(raw);
      if (mrn) return { mrn, raw };

      // 2) Fallback to Quagga2
      raw = await quaggaDecodeFromBlob(blobOrFile);
      mrn = normalizeMrn(raw);
      return { mrn, raw };
    }

    function extractMrnFromOCR(text){
      const m = (text || "").match(/\b(UPM\d{6,12})\b/i);
      return m ? m[1].toUpperCase() : null;
    }

    document.getElementById("mcForm").addEventListener("submit", onSubmit);

    async function onSubmit(e){
      e.preventDefault();
      const zone = document.getElementById("zone").value;
      const stickerFile = stickerInput.files[0];
      const mcFile = mcInput.files[0];

      if (!zone || !stickerFile || !mcFile) {
        alert("Please complete all fields.");
        return;
      }

      // Decide sources
      const nameSource = stickerNameCroppedBlob || stickerFile;
      const barcodeSource = stickerBarcodeCroppedBlob || stickerFile;
      const mcSource = mcCroppedBlob || mcFile;

      setStatus("Reading barcode for MRN…");
      const barcode = await extractMrnFromBarcode(barcodeSource);

      setStatus("Running OCR on Name…");
      const nameOcr = await runNameOCR(nameSource);

      // Apply overrides & fallbacks
      let name = nameManual.value.trim() || nameOcr || "";
      let mrn = (mrnManual.value.trim().toUpperCase()) || barcode.mrn || extractMrnFromOCR(nameOcr) || "";

      // UI preview
      ocrBox.textContent = `Name=${name || "—"} | MRN=${mrn || "—"}`;

      setStatus("Uploading to Drive & writing to Sheet…");
      submitBtn.disabled = true;

      try {
        const [stickerB64, mcB64] = await Promise.all([
          fileOrBlobToBase64(barcodeSource), // send the barcode-cropped (or full) sticker
          fileOrBlobToBase64(mcSource)
        ]);

        const payload = {
          zone,
          ocrText: nameOcr,             // for server logging only
          nameOverride: name || null,   // enforce final name
          mrnOverride: mrn || null,     // enforce final MRN (from barcode or manual)
          barcodeRaw: barcode.raw || null,
          sticker: { name: stickerFile.name, mime: "image/jpeg", b64: stickerB64 },
          mcfile:  { name: mcFile.name,     mime: "image/jpeg", b64: mcB64 }
        };

        const resp = await fetch(GAS_URL, { method: "POST", body: JSON.stringify(payload) });
        if (!resp.ok) {
          const txt = await resp.text();
          throw new Error(`HTTP ${resp.status} – ${txt.slice(0,200)}`);
        }
        const data = await resp.json();
        if (!data.ok) throw new Error(data.error || "Unknown server error");

        setStatus("Success ✔ Files uploaded & row added.", true);
        ocrBox.textContent = `Name=${data.name || name || "—"} | MRN=${data.mrn || mrn || "—"}\nSticker: ${data?.sticker?.url || "—"}\nMC: ${data?.mc?.url || "—"}`;
        alert("OK:\n" + JSON.stringify(data, null, 2));
      } catch (err) {
        console.error(err);
        setStatus("Failed: " + err.message, false, true);
        alert("Error:\n" + err.message);
      } finally {
        submitBtn.disabled = false;
      }
    }
  </script>
</body>
</html>
