<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Medical Certificate (MC) Use — Mobile</title>
  <style>
    :root { --gap: 12px; }
    * { box-sizing: border-box; }
    html, body { margin:0; padding:0; }
    body {
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      line-height: 1.35; color:#111; background:#fff; overflow-x:hidden;
    }
    .wrap { max-width: 680px; width:100%; margin: 16px auto 56px; padding: 0 12px; }
    h2 { margin: 8px 0 6px; font-size: 1.25rem; }
    .muted { color:#666; font-size:.92rem; margin-bottom: 10px; }

    fieldset { border: 1px solid #e5e5e5; border-radius: 12px; padding: 12px; }
    label { display:block; margin: 10px 0 6px; font-weight:600; }
    select, input[type=file], input[type=text], button {
      display:block; width:100%; font-size:16px; padding:10px; border-radius:12px;
      border:1px solid #d7d7d7; background:#fff;
    }
    input[type=file]{ padding:8px; }
    button { background:#0a7a2f; color:#fff; border:none; font-weight:600; }
    button:disabled { opacity:.6; }

    .grid { display:grid; grid-template-columns:1fr; gap:var(--gap); }
    @media (min-width:900px) { .grid.two { grid-template-columns:1fr 1fr; } }

    .preview {
      width:100%; height:auto; max-height:240px; object-fit:contain;
      border:1px dashed #cfcfcf; border-radius:12px; background:#fafafa;
    }

    .log {
      font-family: ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;
      font-size:.95rem; white-space:pre-wrap; background:#fafafa; border:1px solid #eee;
      border-radius:12px; padding:10px;
    }
    .ok{color:#0a7a2f}.err{color:#b00020}
  </style>

  <!-- OCR -->
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@4/dist/tesseract.min.js"></script>
  <!-- HEIC -> JPEG -->
  <script src="https://cdn.jsdelivr.net/npm/heic2any@0.0.4/dist/heic2any.min.js"></script>
  <!-- Quagga2 (barcode fallback if native API fails) -->
  <script src="https://cdn.jsdelivr.net/npm/quagga2@1.8.4/dist/quagga.min.js"></script>
</head>
<body>
  <div class="wrap">
    <h2>Medical Certificate (MC) Use</h2>
    <p class="muted">Sticker is processed locally and never uploaded. Only the MC photo is saved to Drive.</p>

    <form id="mcForm">
      <fieldset>
        <label for="zone">Zone</label>
        <select id="zone" required>
          <option value="">— Select —</option>
          <option>Green</option>
          <option>Yellow</option>
          <option>Red</option>
        </select>

        <div class="grid two">
          <div>
            <label for="sticker">Patient sticker photo (local only)</label>
            <input type="file" id="sticker" accept="image/*" capture="environment" required />
            <img id="stickerPreview" class="preview" alt="">
            <div class="muted">Fill the frame with the sticker if you can; we auto-find the barcode and the name above it.</div>
          </div>
          <div>
            <label for="mcfile">Medical Certificate photo (saved)</label>
            <input type="file" id="mcfile" accept="image/*" capture="environment" required />
            <img id="mcPreview" class="preview" alt="">
          </div>
        </div>

        <div class="grid two" style="margin-top: var(--gap)">
          <div>
            <label>Detected</label>
            <div id="parsed" class="log">— waiting —</div>
          </div>
          <div>
            <label>Manual override (optional)</label>
            <input type="text" id="nameManual" placeholder="Name (override)">
            <input type="text" id="mrnManual" placeholder="MRN (UPMxxxxxxxxx)">
          </div>
        </div>

        <div style="margin-top: var(--gap)">
          <button id="submitBtn" type="submit">Submit</button>
        </div>
      </fieldset>
    </form>

    <div style="margin-top: var(--gap)">
      <div id="status" class="log">Status: idle</div>
    </div>
  </div>

  <script>
    /* ===== CONFIG ===== */
    const GAS_URL = "https://script.google.com/macros/s/AKfycbwoijzTp_nlEfdXawiLNxPXu0e5sH9qM5FOSJFkzJVoUA0kGZjRAbZAcM1wUJmRwMuC/exec"; // /exec
    const MAX_DIM = 1600;            // larger resize improves barcode reliability
    const OCR_TIMEOUT_MS = 7000;     // hard timeouts so UI never hangs
    const BARCODE_TIMEOUT_MS = 4000;

    /* ===== DOM ===== */
    const $ = id => document.getElementById(id);
    const zoneEl = $("zone");
    const stickerEl = $("sticker"), mcEl = $("mcfile");
    const stickerPreview = $("stickerPreview"), mcPreview = $("mcPreview");
    const parsedEl = $("parsed"), statusEl = $("status");
    const nameManual = $("nameManual"), mrnManual = $("mrnManual");
    const submitBtn = $("submitBtn");

    let stickerBlob = null, mcBlob = null;

    const setStatus = (msg, ok=false, err=false) => {
      statusEl.textContent = msg;
      statusEl.className = "log" + (ok ? " ok" : "") + (err ? " err" : "");
    };

    /* ===== Utilities ===== */
    function fitWithin(w,h,max){ const s = Math.min(1, max/Math.max(w,h)); return {w:Math.round(w*s), h:Math.round(h*s)}; }
    function blobToImage(blob){ return new Promise((res,rej)=>{ const u=URL.createObjectURL(blob); const i=new Image(); i.onload=()=>{URL.revokeObjectURL(u);res(i)}; i.onerror=rej; i.src=u; }); }
    function blobToBase64(b){ return new Promise((res,rej)=>{ const fr=new FileReader(); fr.onload=()=>res(String(fr.result).split(",")[1]||""); fr.onerror=rej; fr.readAsDataURL(b); }); }
    function showPreview(blob, imgEl){ const url=URL.createObjectURL(blob); imgEl.src=url; imgEl.onload=()=>URL.revokeObjectURL(url); }

    async function normalize(file){
      // Convert HEIC → JPEG if needed
      if (/image\/hei(c|f)/i.test(file.type) || /\.hei(c|f)$/i.test(file.name)) {
        const r = await heic2any({ blob:file, toType:"image/jpeg", quality:0.92 });
        file = new File([Array.isArray(r)?r[0]:r], (file.name.replace(/\.[^\.]+$/,'')||'image')+".jpg", { type:"image/jpeg" });
      }
      // Resize for speed & clarity
      const img = await blobToImage(file);
      const {w,h} = fitWithin(img.naturalWidth||img.width, img.naturalHeight||img.height, MAX_DIM);
      const can = document.createElement("canvas"); can.width=w; can.height=h;
      const ctx = can.getContext("2d"); ctx.drawImage(img, 0, 0, w, h);
      const blob = await new Promise(r => can.toBlob(r, "image/jpeg", 0.9));
      return blob;
    }

    async function rotateBlob(blob, deg){
      if (deg % 360 === 0) return blob;
      const img = await blobToImage(blob);
      const w = img.naturalWidth||img.width, h = img.naturalHeight||img.height;
      const rad = (deg % 360) * Math.PI/180;
      const cw = (deg % 180 === 0) ? w : h;
      const ch = (deg % 180 === 0) ? h : w;
      const can = document.createElement("canvas"); can.width=cw; can.height=ch;
      const ctx = can.getContext("2d");
      ctx.translate(cw/2, ch/2); ctx.rotate(rad); ctx.drawImage(img, -w/2, -h/2);
      return await new Promise(r => can.toBlob(r, "image/jpeg", 0.9));
    }

    function withTimeout(promise, ms){ let t; return Promise.race([ promise.finally(()=>clearTimeout(t)), new Promise(r=>{t=setTimeout(()=>r(null),ms);}) ]); }

    /* ===== Barcode detection ===== */
    async function nativeDetect(blob){
      if (!("BarcodeDetector" in window)) return null;
      try{
        let formats = ['code_128','code_39','code_93','itf','codabar','ean_13','ean_8','pdf417'];
        try {
          const supported = await BarcodeDetector.getSupportedFormats();
          formats = formats.filter(f => supported.includes(f));
        } catch(_) {}
        const detector = new BarcodeDetector({ formats });
        const bmp = await createImageBitmap(blob);
        const codes = await detector.detect(bmp);
        if (!codes?.length) return null;
        // choose the longest value (often the MRN barcode, not QR/others)
        let best = codes[0];
        for (const c of codes) if ((c.rawValue||'').length > (best.rawValue||'').length) best = c;
        const bb = best.boundingBox || (best.cornerPoints ? rectFromPoints(best.cornerPoints) : null);
        return { raw:String(best.rawValue||'').trim(), bbox: bb };
      }catch(_){ return null; }
    }
    function rectFromPoints(pts){
      const xs = pts.map(p=>p.x), ys=pts.map(p=>p.y);
      const x = Math.min(...xs), y=Math.min(...ys);
      const w = Math.max(...xs)-x, h=Math.max(...ys)-y;
      return { x, y, width:w, height:h };
    }
    function quaggaDetect(blob){
      return new Promise(resolve=>{
        const url = URL.createObjectURL(blob);
        Quagga.decodeSingle({
          src:url, numOfWorkers:0, locate:true,
          inputStream:{ size:1280 },
          locator:{ halfSample:false, patchSize:"medium" },
          decoder:{ readers:["code_128_reader","code_39_reader","code_93_reader","i2of5_reader","codabar_reader","ean_reader","ean_8_reader"] }
        }, res=>{
          URL.revokeObjectURL(url);
          if (res?.codeResult?.code){
            const pts = res?.box || [];
            const bbox = pts.length ? rectFromPoints(pts.map(([x,y])=>({x,y}))) : null;
            resolve({ raw: String(res.codeResult.code), bbox });
          } else resolve(null);
        });
        setTimeout(()=>{ try{URL.revokeObjectURL(url);}catch{} resolve(null); }, BARCODE_TIMEOUT_MS-100);
      });
    }
    function normalizeMrn(raw){
      if (!raw) return null;
      const upm = (raw.match(/\b(UPM\d{6,12})\b/i)||[])[1];
      if (upm) return upm.toUpperCase();
      const digits = (raw.match(/\b(\d{6,12})\b/)||[])[1];
      return digits ? ("UPM"+digits) : null;
    }

    async function detectBarcodeAllAngles(blob){
      // Try 0, 90, 180, 270 with native first, then Quagga
      const angles = [0,90,180,270];
      for (const a of angles){
        const b = await rotateBlob(blob, a);
        const native = await withTimeout(nativeDetect(b), BARCODE_TIMEOUT_MS);
        if (native && normalizeMrn(native.raw)) return { ...native, angle:a, blob:b };
      }
      for (const a of angles){
        const b = await rotateBlob(blob, a);
        const q = await withTimeout(quaggaDetect(b), BARCODE_TIMEOUT_MS);
        if (q && normalizeMrn(q.raw)) return { ...q, angle:a, blob:b };
      }
      return null;
    }

    /* ===== Crop a name ROI above the barcode bbox ===== */
    async function cropAboveBarcode(blob, bbox){
      // Take a region just above the barcode: ~2x barcode height, same width + margins
      if (!bbox) return null;
      const img = await blobToImage(blob);
      const W = img.naturalWidth||img.width, H = img.naturalHeight||img.height;
      const m = Math.round(Math.max(6, bbox.height*0.25));
      const x = Math.max(0, Math.floor(bbox.x - m));
      const w = Math.min(W - x, Math.floor(bbox.width + 2*m));
      const y2 = Math.max(0, Math.floor(bbox.y - m)); // bottom boundary just above barcode
      const h = Math.min(H, Math.floor(2*bbox.height + m)); // look a bit higher for multi-line names
      const y = Math.max(0, y2 - h);

      const can = document.createElement("canvas"); can.width=w; can.height=h;
      const ctx = can.getContext("2d");
      ctx.drawImage(img, x, y, w, h, 0, 0, w, h);
      return await new Promise(r => can.toBlob(r, "image/jpeg", 0.95));
    }

    /* ===== OCR (prefer single-line uppercase name) ===== */
    async function ocrName(blob){
      if (!blob) return "";
      try{
        const { createWorker } = Tesseract;
        const worker = await createWorker({ logger:()=>{} });
        await worker.loadLanguage("eng");
        await worker.initialize("eng");
        await worker.setParameters({
          tessedit_char_whitelist: "ABCDEFGHIJKLMNOPQRSTUVWXYZ @'-.",
          preserve_interword_spaces: "1",
          tessedit_pageseg_mode: "7"  // single line
        });
        const res = await withTimeout(worker.recognize(blob), OCR_TIMEOUT_MS);
        await worker.terminate();
        if (!res) return "";
        let t = String(res.data?.text || "").toUpperCase().replace(/\s{2,}/g,' ').trim();
        t = t.replace(/^[^A-Z0-9]+|[^A-Z0-9 @'\.-]+$/g,'').trim();
        return t;
      }catch(_){ return ""; }
    }

    function fallbackNameFromWhole(text){
      const lines = String(text||"").toUpperCase().split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
      const pick = lines.find(t => t && !/\d/.test(t)) || "";
      return pick.replace(/^[^A-Z0-9]+|[^A-Z0-9 @'\.-]+$/g,'').trim();
    }

    async function ocrWhole(blob){ // only for last-resort fallback
      try{
        const { createWorker } = Tesseract;
        const worker = await createWorker({ logger:()=>{} });
        await worker.loadLanguage("eng");
        await worker.initialize("eng");
        const res = await withTimeout(worker.recognize(blob), 5000);
        await worker.terminate();
        return res?.data?.text || "";
      }catch(_){ return ""; }
    }

    /* ===== Input hooks ===== */
    stickerEl.addEventListener("change", async ()=>{
      if (!stickerEl.files[0]) return;
      setStatus("Processing sticker…");
      stickerBlob = await normalize(stickerEl.files[0]);
      showPreview(stickerBlob, stickerPreview);

      // Detect barcode (any angle), then OCR above it for name
      setStatus("Detecting barcode & name…");
      let name="", mrn="";
      const hit = await detectBarcodeAllAngles(stickerBlob);
      if (hit){
        mrn = normalizeMrn(hit.raw) || "";
        const nameCrop = await cropAboveBarcode(hit.blob, hit.bbox);
        name = await ocrName(nameCrop);
      }

      // Fallbacks if either missing
      if (!mrn) {
        const txt = await withTimeout(ocrWhole(stickerBlob), 4000);
        const m = (txt||"").match(/\b(UPM\d{6,12})\b/i);
        if (m) mrn = m[1].toUpperCase();
      }
      if (!name) {
        const txt = await withTimeout(ocrWhole(stickerBlob), 4000);
        name = fallbackNameFromWhole(txt);
      }

      parsedEl.textContent = `Name=${name || "—"}  |  MRN=${mrn || "—"}`;
      setStatus("Sticker processed", true);
    });

    mcEl.addEventListener("change", async ()=>{
      if (!mcEl.files[0]) return;
      setStatus("Processing MC photo…");
      mcBlob = await normalize(mcEl.files[0]);
      showPreview(mcBlob, mcPreview);
      setStatus("MC ready", true);
    });

    /* ===== Submit (only MC is uploaded) ===== */
    document.getElementById("mcForm").addEventListener("submit", onSubmit);
    async function onSubmit(e){
      e.preventDefault();
      if (!zoneEl.value || !stickerEl.files[0] || !mcEl.files[0]) {
        alert("Please complete all fields."); return;
      }
      if (!stickerBlob) stickerBlob = await normalize(stickerEl.files[0]);
      if (!mcBlob) mcBlob = await normalize(mcEl.files[0]);

      // Ensure we have values one more time (quick pass)
      setStatus("Finalizing fields…");
      let finalName = nameManual.value.trim();
      let finalMrn  = mrnManual.value.trim().toUpperCase();

      if (!finalName || !finalMrn) {
        const hit = await detectBarcodeAllAngles(stickerBlob);
        if (!finalMrn && hit) finalMrn = normalizeMrn(hit.raw) || "";
        if (!finalName && hit){
          const crop = await cropAboveBarcode(hit.blob, hit.bbox);
          finalName = await ocrName(crop);
        }
      }

      parsedEl.textContent = `Name=${finalName || "—"}  |  MRN=${finalMrn || "—"}`;

      setStatus("Uploading MC & writing row…");
      submitBtn.disabled = true;
      try{
        const mcB64 = await blobToBase64(mcBlob);
        const payload = {
          zone: zoneEl.value,
          nameOverride: finalName || null,
          mrnOverride: finalMrn || null,
          mcfile: { name: mcEl.files[0].name, mime: "image/jpeg", b64: mcB64 }
        };
        const resp = await fetch(GAS_URL, { method:"POST", body: JSON.stringify(payload) });
        if (!resp.ok){ const txt = await resp.text(); throw new Error(`HTTP ${resp.status} – ${txt.slice(0,200)}`); }
        const data = await resp.json();
        if (!data.ok) throw new Error(data.error || "Unknown server error");

        setStatus("Success ✔ Files uploaded & row added.", true);
        parsedEl.textContent = `Name=${data.name || finalName || "—"}  |  MRN=${data.mrn || finalMrn || "—"}\nMC: ${data?.mc?.url || "—"}`;
      }catch(err){
        console.error(err);
        setStatus("Failed: " + err.message, false, true);
        alert("Error:\n" + err.message);
      }finally{
        submitBtn.disabled = false;
      }
    }
  </script>
</body>
</html>
